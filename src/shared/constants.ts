export const HTML_CSS_QUESTIONS = [
  {
    number: 1,
    title: `Что такое HTML и CSS? Для чего они используются?`,
    shortAnswer: '',
    longAnswer: `<strong>HTML —</strong> <span>это язык разметки, который используется для создания структуры веб-страницы.<br>
    Он определяет, какие элементы будут присутствовать на странице и как они структурированы.</span><br>
    
    <strong>CSS —</strong> <span>это язык таблиц стилей, который используется для оформления внешнего вида веб-страницы.<br>
    Он позволяет управлять стилем и расположением элементов на странице.</span><br><br>
    
    <strong>Как работают вместе:</strong><br>
    <span>HTML задает структуру, а CSS — стили и дизайн. Например, HTML создаст заголовок, а CSS задаст его цвет и выравнивание.<br>
    Пример совместного использования:</span>`,
    frequency: 4,
    language: "html",
    codeExample: `<!DOCTYPE html>
<html lang="ru">
<head>
  <title>Пример страницы</title>
  <style>
    h1 {
      color: blue;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Привет, мир!</h1>
</body>
</html>`
  },
  {
    number: 2,
    title: `Cемантика HTML, и зачем ее использовать?`,
    shortAnswer: '',
    longAnswer: `<strong>Семантический HTML —</strong> <span>это использование HTML-тегов, которые ясно и точно описывают смысл
    их содержимого. В отличие от несемантических тегов, таких как <code>&lt;div&gt;</code> и <code>&lt;span&gt;</code>, семантические
    теги, например, <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;nav&gt;</code>, имеют четкое назначение и облегчают
    понимание структуры веб-страницы.</span><br> <strong>Преимущества семантического HTML:</strong> <span><br><b>Улучшение доступности (Accessibility):</b><br>
    Семантические теги помогают скринридерам (программам для чтения с экрана) понимать структуру страницы, что особенно важно для пользователей с ограниченными возможностями. Например, <code>&lt;nav&gt;</code> обозначает навигационный блок, что позволяет скринридеру быстро перемещаться
    по странице.<br><b>SEO (поисковая оптимизация):</b>
    Поисковые системы, такие как Google, используют семантические теги для определения важности
    контента. Это помогает улучшить ранжирование сайта в поисковых системах.<br><b>Поддерживаемость и читаемость кода:</b>
    Семантический HTML делает код более понятным для других разработчиков. Например, <code>&lt;article&gt;</code> сразу
    подсказывает, что внутри находится самостоятельный блок контента.
    Улучшение пользовательского опыта:
    Семантические теги позволяют браузерам и другим устройствам, например, умным колонкам,
    интерпретировать и отображать контент наиболее подходящим образом.
    <br><b>Соответствие стандартам:</b>
    Использование семантических тегов способствует написанию валидного кода, который соответствует
    стандартам W3C.</span><br><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 3,
    title: `Основные семантические теги и их назначение ?`,
    shortAnswer: '',
    longAnswer: `<strong><code>&lt;header&gt;</code></strong><span> Используется для создания шапки страницы или раздела.</span><br>
     <strong>Пример содержания:</strong><span> логотип, навигация, заголовок.</span><br><br>
     <strong><code>&lt;footer&gt;</code></strong><span> Определяет нижний колонтитул страницы или секции.</span><br>
     <strong>Пример содержания:</strong><span> контактная информация, копирайт, ссылки на политику конфиденциальности.</span><br><br>
     <strong><code>&lt;main&gt;</code></strong><span> Содержит основной контент страницы, уникальный для данной страницы.</span><br>
     <strong>Пример содержания:</strong><span> содержит только уникальный контент страницы (основной контент).</span><br><br>
     <strong><code>&lt;section&gt;</code></strong><span> Используется для группировки связанных по смыслу элементов. Обычно имеет заголовок.</span><br><br>
     <strong><code>&lt;article&gt;</code></strong><span> Определяет самостоятельный блок контента, например, статью, новость или пост.</span><br><br>
     <strong><code>&lt;aside&gt;</code></strong><span> Определяет дополнительный контент, связанный с основным, например, боковую панель,
     рекламу, ссылки.</span><br><br>
     <strong><code>&lt;nav&gt;</code></strong><span> Определяет навигационное меню или группу ссылок.</span><br><br>
     <strong><code>&lt;figure&gt;</code> и <code>&lt;figcaption&gt;</code></strong><span> Используются для добавления иллюстраций с подписью..</span><br><br>
     <strong><code>&lt;time&gt;</code></strong><span> Указывает дату или время в стандартизированном формате.</span><br><br>
     <strong><code>&lt;mark&gt;</code></strong><span> Подсвечивает текст, имеющий важное значение.</span><br><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 4,
    title: `Какие типы полей ввода доступны через тег <input>?`,
    shortAnswer: '',
    longAnswer: `<strong><code>&lt;text&gt;</code></strong><span> Обычное текстовое поле для ввода текста.</span><br>
    <strong><code>&lt;password&gt;</code></strong> <span>Поле для ввода пароля. Текст скрыт с помощью символов (например, звездочек).</span><br>
    <strong><code>&lt;email&gt;</code></strong><span> Поле для ввода email-адреса. Браузер может проверять корректность ввода email.</span><br>
    <strong><code>&lt;number&gt;</code></strong><span> Поле для ввода чисел. Может иметь ограничения на минимальные и
    максимальные значения.</span><br>
    <strong><code>&lt;tel&gt;</code></strong> <span>Поле для ввода телефонного номера. Не проверяет формат ввода, но браузер может
    предложить клавиатуру, подходящую для ввода номера телефона.</span><br>
    <strong><code>&lt;url&gt;</code></strong> <span>Поле для ввода URL-адреса. Браузер может проверить правильность формата.</span><br>
    <strong><code>&lt;date&gt;</code></strong> <span>Поле для ввода даты. Браузер отображает календарь для выбора даты.</span><br>
    <strong><code>&lt;time&gt;</code></strong> <span>Поле для ввода времени (часы и минуты).</span><br>
    <strong><code>&lt;datetime-local&gt;</code></strong> <span>Поле для ввода даты и времени (без указания часового пояса).</span><br>
    <strong><code>&lt;month&gt;</code></strong> <span>Поле для ввода месяца и года.</span><br>
    <strong><code>&lt;week&gt;</code></strong> <span>Поле для ввода года и недели.</span><br>
    <strong><code>&lt;search&gt;</code></strong> <span>Поле для ввода поискового запроса. Это поле имеет семантическое значение для
    поиска.</span><br>
    <strong><code>&lt;file&gt;</code></strong> <span>Поле для выбора файла с устройства пользователя. Можно задать атрибуты для
    ограничения типов файлов.</span><br>
     <strong><code>&lt;checkbox&gt;</code></strong> <span>Поле для выбора одного или нескольких вариантов из предложенного списка</span><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 5,
    title: `Как связать <label> с <input>?`,
    shortAnswer: '',
    longAnswer: `<strong>Для связывания элемента <code>&lt;label&gt;</code> с элементом <code>&lt;input&gt;</code></strong>
    
    <span>в HTML используется атрибут for в теге
    <code>&lt;label&gt;</code> и атрибут id в теге <code>&lt;input&gt;</code>. Это связывание позволяет улучшить доступность формы и облегчить
    взаимодействие с пользователем.</span>`,
    frequency: 4,
    language: "html",
    codeExample: `<form action="/submit" method="POST">
    <label for="username">Username:</label>
    <input 
      type="text" 
      id="username" 
      name="username" 
      required 
      placeholder="Введите ваше имя"
    >
  
    <label for="email">Email:</label>
    <input 
      type="email" 
      id="email" 
      name="email" 
      required 
      placeholder="Введите ваш email"
    >
  
    <input type="submit" value="Отправить">
  </form>`
  },
  {
    number: 6,
    title: `Что такое каскад в CSS?`,
    shortAnswer: '',
    longAnswer: `<strong>Каскад (Cascade) в CSS —</strong><span>это принцип, по которому браузер решает, какие стили применить к элементам,
    когда существует несколько правил, применяемых к одному элементу. Каскад предполагает, что стили
    могут поступать из разных источников и могут перекрывать друг друга в зависимости от их специфичности,
    важности и порядка объявления.</span><br>
    <strong>Основные принципы каскада:</strong><br>
    <strong>Источник стилей:</strong><span> стили могут поступать из разных мест:
    Встроенные стили (внутри тега <code>&lt;style&gt;</code> в HTML или атрибут style на элементах)
    Внешние таблицы стилей (подключенные через тег <code>&lt;link&gt;</code>)
    Браузерные стили по умолчанию (если для элемента не указаны стили, браузер применяет свои дефолтные
    стили).</span><br><strong>Специфичность:</strong><span> это правило, которое определяет, какое правило имеет больший
    «приоритет». Чем более конкретным является селектор, тем выше его специфичность. Например:
    Селектор по тегу, такой как div, имеет низкую специфичность.
    Селектор по классу, такой как .class-name, имеет более высокую специфичность.
    Селектор по идентификатору, такой как #id-name, имеет еще более высокую специфичность.
    Inline-стили (например, style="..." на элементе) имеют наивысший приоритет.</span><br>
    <strong>Порядок объявления:</strong><span> если два правила имеют одинаковую специфичность, то браузер применит последнее
    объявленное правило. То есть, если одно правило приходит позже другого, оно будет иметь больший приоритет.</span><br>
    <strong>Важность (!important):</strong><span>Атрибут !important позволяет принудительно дать стиль более высокий приоритет,
    независимо от специфичности и порядка. Использование !important делает стиль наиболее важным, но его
    нужно применять осторожно, так как он нарушает нормальный порядок каскад</span>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 7,
    title: `Псевдоклассы и псевдоэлементы?`,
    shortAnswer: '',
    longAnswer: `<strong>Псевдоклассы</strong><span> позволяют применять стили к элементам в определённом состоянии, например, когда они
    находятся в фокусе, на них наведена мышь, или они являются дочерними элементами какого-либо другого
    элемента.</span><br>
    <strong>:hover</strong><span> применяется к элементу, когда на него наводится курсор.</span><br>
    <strong>:focus</strong><span> применяется к элементу, когда он получает фокус, например, после клика или навигации с клавиатуры.</span><br>
    <strong>:active</strong><span> применяется к элементу в момент его активации, обычно при клике на элемент.</span><br>
    <strong>:visited</strong><span> применяется к ссылке, которую уже посещал пользователь.</span><br>
    <strong>:checked</strong><span> применяется к элементам формы (например, checkbox или radio), которые находятся в состоянии
    "отмечено" или "выбрано".</span><br>
    <strong>:disabled</strong><span> применяется к элементам формы, которые отключены (disabled).</span><br>
    <strong>:first-child</strong><span> применяется к первому дочернему элементу родителя.</span><br>
    <strong>:last-child</strong><span> применяется к последнему дочернему элементу родителя.</span><br>
    <strong>:nth-child()</strong><span> применяется к элементу, который является n-м дочерним элементом родителя. Можно
    использовать различные выражения для выбора элементов, например, :nth-child(2), :nth-child(odd)&nbsp;, :nth-child(3n)</span><br><br>
    <strong>Псевдоэлементы</strong><span> позволяют стилизовать несуществующие или скрытые части элементов, такие как текст до
    или после элемента, или первую букву/строку текста в блоке.</span><br>
    <strong>::before</strong><span> — вставляет контент перед содержимым элемента. Обычно используется для добавления иконок или
    текста перед содержимым.</span><br>
    <strong>::after</strong><span> — вставляет контент после содержимого элемента. Применяется для добавления декоративных
    элементов или текста после основного контента.`,
    frequency: 4,
    language: "html",
  },
  {
    number: 8,
    title: `Какие существуют виды позиционирования в CSS? Чем отличаются absolute, relative, fixed и sticky?`,
    shortAnswer: '',
    longAnswer: `<strong>Виды позиционирования:</strong><span><br><br>
    <strong>Static (статическое позиционирование)</strong><span> - элемент размещается в документе в порядке потока, сверху вниз.</span><br>
    <strong>Relative (относительное позиционирование)</strong><span> - элемент остаётся в потоке документа, но можно сдвинуть его
    относительно самого себя с помощью top, right, bottom, left.</span><br>
    <strong>Absolute (абсолютное позиционирование)</strong><span> - позиционируется относительно ближайшего предка с position: relative,
    absolute, или sticky.</span><br>
    <strong>Fixed (фиксированное позиционирование)</strong><span> - элемент фиксируется относительно окна браузера. Не сдвигается
    при прокрутке страницы. Всегда остаётся на одном месте.</span><br>
    <strong>Sticky (прилипшее позиционирование)</strong><span> - элемент комбинирует свойства relative и fixed:
    Работает как relative, пока не достигает указанного значения (top, left, и т. д.).
    Затем "прилипает" и ведёт себя как fixed относительно окна.</span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `.sticky-header {
    position: sticky;
    top: 0;
    background-color: orange;
    padding: 10px;
    font-size: 20px;
    font-weight: bold;
    text-align: center;
    border-bottom: 2px solid darkorange;
}`
  },
  {
    number: 9,
    title: `Как работает Flexbox и Grid?`,
    shortAnswer: '',
    longAnswer: `<strong>Flexbox (Flexible Box Layout) — </strong><span> - это технология в CSS, предназначенная для создания гибких и адаптивных
    макетов. Она позволяет удобно управлять расположением элементов внутри контейнера и их поведением
    при изменении размера контейнера. Flexbox позволяет выравнивать, распределять пространство между
    элементами и управлять их размерами в зависимости от доступного пространства.</span><br>
    <strong>Как работает Flexbox?</strong><span> Flexbox работает на основе контейнера, который становится flex-контейнером, и его дочерних элементов —
    flex-элементов. Все элементы внутри flex-контейнера могут быть расположены с использованием различных
    правил, таких как выравнивание, распределение пространства и изменение размеров.</span><br>
    <strong>Преимущества Flexbox:</strong><span><br>
    <span>Гибкость: Легко создавать адаптивные макеты.<br>
    Центрирование: Простое выравнивание элементов по горизонтали и вертикали.<br>
    Динамическое изменение: Элементы могут изменять свои размеры в зависимости от доступного пространства.</span><br>
    <strong>CSS Grid — </strong><span>это система макета в CSS, предназначенная для создания сложных двухмерных макетов (как по
    вертикали, так и по горизонтали). Она позволяет удобно и гибко управлять расположением элементов на
    странице, используя сетку с рядами и колонками. В отличие от Flexbox, который работает с элементами в одном
    направлении (либо по горизонтали, либо по вертикали), Grid позволяет работать с элементами как в строках,
    так и в колонках одновременно.</span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `.container {
    display: flex; 
    justify-content: space-between; /* Равномерно распределяем карточки */
    align-items: center; /* Выравнивание по центру */
    flex-wrap: wrap; /* Перенос элементов на новую строку, если не помещаются */
    gap: 20px; /* Расстояние между карточками */
    padding: 20px;
}
`
  },
  {
    number: 10,
    title: `Что такое медиа-запросы?`,
    shortAnswer: '',
    longAnswer: `<strong>Медиа-запросы (или media queries) — </strong><span> это важный инструмент в CSS, который позволяет применять
    различные стили в зависимости от характеристик устройства или окна браузера, таких как его ширина, высота,
    разрешение экрана, ориентация и другие параметры. Они играют ключевую роль в создании адаптивной
    верстки (responsive design), позволяя веб-страницам автоматически адаптироваться под различные экраны и
    устройства (от смартфонов до десктопов).</span><br>
    <strong>Применение медиа-запросов для адаптивной верстки</strong><br>
    <span>Адаптивная верстка позволяет страницам изменять свой дизайн в зависимости от размеров экрана устройства.
    С помощью медиа-запросов можно:
    Менять структуру и размеры элементов. Например, изменить количество колонок в сетке, уменьшить размеры
    текста на мобильных устройствах или скрыть ненужные элементы.
    Реализовывать мобильные версии. Например, на мобильных устройствах можно скрывать боковые панели
    или изменить навигацию для лучшего пользовательского опыта.
    Создавать мультимедийные страницы. Медиа-запросы позволяют адаптировать контент под разные виды
    устройств (например, планшеты и смартфоны).<span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `@media (max-width: 768px) {
    .container {
        flex-direction: column; /* Карточки будут в колонку */
        align-items: center;
    }

    .card {
        max-width: 100%; /* Карточки займут всю ширину контейнера */
    }
}
`
  },
  {
    number: 11,
    title: `Чем отличается inline, block, и inline-block?`,
    shortAnswer: '',
    longAnswer: `<strong>Inline (Строчные элементы)</strong><br><br>
    <span>• Занимает только столько места, сколько необходимо содержимому.<br>
    • Нельзя задавать width и height, они игнорируются.<br>
    • На одной строке может находиться несколько inline-элементов.<br>
    <strong>Пример:</strong> <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code><br><br>
    <strong>Block (Блочные элементы)</strong><br><br>
    <span>• Занимает всю ширину родительского контейнера.<br>
    • Начинается с новой строки.<br>
    • Можно задавать width, height, margin, padding.<br>
    <strong>Пример:</strong> <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;section&gt;</code><br><br>
    <strong>Inline-block (Комбинированный)</strong><br><br>
    <span>• Ведёт себя как inline (не переносится на новую строку).<br>
    • Позволяет задавать width, height, margin, padding (в отличие от inline).<br>
    • Используется для создания гибких элементов (например, кнопки, меню, карточки).<br>`,
    frequency: 4,
    language: "css",
  },
];

export const JAVASCRIPT_QUESTIONS = [
  {
    number: 1,
    title: `Что такое Javascript ?`,
    shortAnswer: '',
    longAnswer: `<strong>Javascript</strong> <span>это язык программирования используемый для создания интерактивных элементов на веб-
    станицах. Он позволяет добавлять динамическое поведение к сайтам, такие как анимации, обработка
    событий, валидация форм и много другое.</span><br>
    <strong>Интерпретируемый язык:</strong> <span>JavaScript выполняется браузером напрямую,без необходимости
    компиляции. Это делает его идеальным для быстрого создания
    и тестирования веб-приложений.</span><br>
    <strong>Многофункциональность:</strong>
    <span>JavaScript можно использовать как на стороне клиента (frontend), так и на
    стороне сервера (backend) с помощью таких сред, как Node.js.</span><br>
    <strong>Асинхронность:</strong>
    <span>JavaScript поддерживает асинхронное выполнение задач через колбэки, промисы и
    async/await, что позволяет обрабатывать запросы и другие задачи, не блокируя основное выполнение
    кода.</span><br>
    <strong>Широкая экосистема:</strong>
    <span>JavaScript обладает большим количеством библиотек
    и фреймворков (React, Angular, Vue), которые упрощают разработку сложных веб-приложений.</span><br>
    <strong>Совместимость:</strong>
    <span>JavaScript поддерживается всеми современными браузерами
    и активно развивается сообществом и стандартами ECMA (например, ES6).</span>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 2,
    title: `Что такое Var Let и Const ?`,
    shortAnswer: '',
    longAnswer: `<strong>Var, Let и Const</strong> <span>это три способа объявления переменных в JavaScript, и они имеют
    различные особенности и области видимости. Вот основные различия между ними:</span><br>
    <strong>Область видимости:</strong><br><span><b>Var:</b> Переменные, объявленные с помощью var, имеют функциональную область видимости (если
    объявлены внутри функции) или глобальную область видимости (если объявлены вне функции). Это
    означает, что они доступны в пределах всей функции или в глобальном контексте.
    <b>Let и Const:</b> Оба имеют блочную область видимости, что означает, что они доступны только
    внутри блока кода, в котором были объявлены (например, внутри фигурных скобок {})</span><br>
    <strong>Повторное объявление:</strong>
    <span><b>Var:</b> Позволяет повторно объявлять переменные. Если вы попытаетесь объявить переменную с тем
    же именем в одной области видимости, это не вызовет ошибки.
    <b>Let:</b> Не позволяет повторное объявление переменных в одной области видимости. Если вы попробуете
    это сделать, получите ошибку.
    <b>Const:</b> Также не позволяет повторное объявление, как и let. Кроме того, переменные, объявленные с
    помощью const, должны быть инициализированы при объявлении и не могут быть переназначены.</span><br>
    <strong>Инициализация:</strong>
    <span><b>Var:</b> Переменные можно объявить без инициализации, и они будут иметь значение undefined по умолчанию.
    <b>Let:</b> Переменные также можно объявить без инициализации и будут иметь значение undefined.
    <b>Const:</b> Обязательно требует инициализации при объявлении. Если вы попытаетесь объявить
    переменную с const без инициализации, получите ошибку.</span><br>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 3,
    title: `Как предотвратить изменение объекта ?`,
    shortAnswer: '',
    longAnswer: `<strong>Метод Object.freeze()</strong> <span>предотвращает изменения в объекте, делая его неизменяемым.
    После применения этого метода нельзя добавлять, удалять или изменять свойства объекта.</span><br>
    <strong>С помощью Object.defineProperty()</strong><span>вы можете установить свойства объекта как неуязвимые для
    изменений. Установив свойство с writable: false, вы запретите его изменение.</span><br>
    <span><b>Дискрипторы</b> свойств в JavaScript определяют характеристики свойств объектов. Каждый дискриптор
    свойства может содержать определенные атрибуты, которые контролируют поведение свойств.</span><br>
    <strong>writable:</strong><span> логическое значение, указывающее, можно ли изменять значение свойства (только для data
    descriptor).</span><br>
    <strong>enumerable:</strong><span> логическое значение, указывающее, перечисляется ли свойство при переборе свойств
    объекта (например, с помощью for...in или Object.keys()).</span><br>
    <strong>configurable:</strong><span> логическое значение, указывающее, можно ли изменять атрибуты свойства и удалять
    его из объекта (если false, то свойство нельзя удалить и его атрибуты нельзя изменять).</span><br>`,
    frequency: 4,
    language: "javascript",
  },
{
  number: 4,
  title: `Как клонировать объект в JS ?`,
  shortAnswer: '',
  longAnswer: `<strong>Поверхностное клонирование (Shallow Copy)</strong><br>
  <span>Метод <b>Object.assign()</b> позволяет создать поверхностную копию объекта
  Оператор распространения <b>(...)</b> также позволяет создать поверхностную копию объекта.</span><br>
  <strong>Глубокое клонирование (Deep Copy)</strong><br>
  <span>1. Использование <b>JSON.parse() и JSON.stringify().</b><span><br>
  <span>2. Для более сложных случаев и для поддержки всех типов данных можно использовать библиотеки,
  такие как <b>Lodash</b>, которая предоставляет функцию <b>_.cloneDeep()</b> для глубокого клонирования
  объектов.<span><br>
  <span>3. Метод <b>structuredClone()</b> позволяет сделать глубокую копию объекта, включая вложенные объекты,
  массивы и многие типы данных (например, Date, Map, Set, ArrayBuffer, и даже циклические структуры).
  Он работает более корректно и эффективно по сравнению с JSON.parse(JSON.stringify()), так как structuredClone
  не имеет ограничений на типы данных и сохраняет циклические ссылки.<span><br>
  <span>4. Написать свою рекурсивную функцию.<span>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj; // Возвращаем примитивы как есть
  }

  if (Array.isArray(obj)) {
    return obj.map(deepClone); // Клонируем массив рекурсивно
  }

  const clonedObj = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clonedObj[key] = deepClone(obj[key]); // Рекурсивное копирование
    }
  }

  return clonedObj;
}
`
},
{
  number: 5,
  title: `Типы данных в Javascript ?`,
  shortAnswer: '',
  longAnswer: `<strong>Примитивные типы данных</strong><br>
  <strong>1. string</strong><span> – для работы с текстом</span><br>
  <strong>2. number</strong><span> – для целых и дробных чисел</span><br>
  <strong>3. boolean</strong><span> – логический тип, который может быть либо true, либо false</span><br>
  <strong>4. undefined</strong><span> – обозначает неопределенное значение. Если переменная объявлена, но не
  инициализирована, она имеет значение undefined</span><br>
  <strong>5. null</strong><span> обозначает “ничто” или “пустое значение”. Это значение может быть явно присвоено переменной</span><br>
  <strong>6. bigint</strong><span> для работы с большими целыми числами, которые не вмещаются в тип number</span><br>
  <strong>7. symbol</strong><span> используется для создания уникальных идентификаторов. Символы гарантированно
  уникальны и часто применяются для создания скрытых или защищенных свойств объекта</span><br>
  <strong>8. Тип object (объект)</strong><span> Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.</span><br>
  `,
  frequency: 4,
  language: "javascript",
},
{
  number: 6,
  title: `Коллекция MAP`,
  shortAnswer: '',
  longAnswer: `<strong>Map в JavaScript</strong>
  <span>— это встроенная структура данных, представляющая коллекцию пар “ключ-значение”.
  Она схожа с объектами, но обладает рядом ключевых особенностей, которые делают её более гибкой и
  удобной для ряда задач.</span><br>
  <strong>Основные характеристики Map</strong><br>
  <strong>1. Гибкость в типах ключей:</strong><span> В отличие от объектов, где ключами могут быть только строки или
  символы, в Map ключами могут быть <b>любые значения:</b> объекты, числа, функции, строки и другие типы
  данных. Это делает Map удобной для хранения различных типов данных в качестве ключей.</span><br>
  <strong>2. Сохранение порядка:</strong><span> Порядок вставки пар “ключ-значение” в Map сохраняется. При итерации
  элементы будут возвращаться в порядке их добавления.</span><br>
  <strong>3. Размер:</strong><span> Map предоставляет свойство size, которое возвращает количество пар “ключ-значение” в
  коллекции.</span><br>
  <strong>4. Производительность:</strong><span> Операции добавления, удаления и поиска в Map обычно быстрее, чем в
  объектах, особенно при работе с большим количеством записей.</span><br>
  <strong>4. Производительность:</strong><span> Операции добавления, удаления и поиска в Map обычно быстрее, чем в
  объектах, особенно при работе с большим количеством записей.</span><br>
  <strong>Основные методы Map</strong><br>
  <strong>set(key, value)</strong><span> добавляет элемент в Map с указанным ключом и значением. Если ключ уже существует,
  его значение будет обновлено.</span><br>
  <strong>get(key)</strong><span> возвращает значение, связанное с ключом. Если ключ не найден, возвращает undefined.</span><br>
  <strong>has(key)</strong><span> проверяет наличие элемента с указанным ключом в Map. Возвращает true, если ключ
  существует, иначе false.</span><br>
  <strong>delete(key)</strong><span> удаляет элемент по ключу и возвращает true, если удаление успешно. Если ключ не найден,
  возвращает false.</span><br>
  <strong>clear()</strong><span> удаляет все элементы из Map.</span><br>
  <strong>size</strong><span> свойство, возвращающее количество элементов в Map.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Создание коллекции Map
  const users = new Map();

  // Добавление элементов в Map
  users.set(1, "Александр");
  users.set(2, "Юлия");
  users.set(3, "Дмитрий");

  console.log(users); // Map(3) { 1 => 'Александр', 2 => 'Юлия', 3 => 'Дмитрий' }

  // Получение значения по ключу
  console.log(users.get(2)); // "Юлия"

  // Проверка наличия ключа
  console.log(users.has(3)); // true
  console.log(users.has(4)); // false

  // Удаление элемента
  users.delete(1);
  console.log(users); // Map(2) { 2 => 'Юлия', 3 => 'Дмитрий' }

  // Получение размера коллекции
  console.log(users.size); // 2`
},
{
  number: 7,
  title: `Коллекция SET`,
  shortAnswer: '',
  longAnswer: `<strong>Set в JavaScript</strong>
  <span> это встроенная коллекция для хранения уникальных значений любого типа. В отличие от массивов, Set не допускает повторяющихся элементов, что делает её полезной в задачах, где важно исключить дубликаты. Рассмотрим подробно, как работает Set, её методы и возможности.</span><br>
  <strong>Основные характеристики Set</strong><br>
  <strong>1. Уникальность элементов:</strong><span> В Set не может быть дубликатов. Если добавить в Set значение, которое уже присутствует, оно не будет добавлено повторно.</span><br>
  <strong>2. Любые типы данных:</strong><span> Как и в Map, в Set можно хранить значения любого типа: строки, числа, объекты, массивы, функции и другие.</span><br>
  <strong>3. Порядок хранения:</strong><span> Порядок вставки элементов в Set сохраняется, что позволяет итерироваться по
  элементам в порядке их добавления.</span><br>
  <strong>4. Оптимизированная производительность:</strong><span> Set обеспечивает быструю проверку наличия элемента, добавление и удаление.</span><br>
  <strong>Основные методы Set</strong><br>
  <strong>add(value)</strong><span> добавляет значение в Set. Если значение уже существует, оно не будет добавлено повторно.</span><br>
  <strong>delete(value)</strong><span> удаляет значение из Set, возвращая true, если значение было удалено, и false, если его не было в коллекции.</span><br>
  <strong>has(value)</strong><span> проверяет, существует ли значение в Set. Возвращает true, если значение есть, иначе false.</span><br>
  <strong>clear()</strong><span> удаляет все значения из Set.</span><br>
  <strong>size</strong><span> свойство, возвращающее количество элементов в Set.</span><br>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `// Создание Set
    const uniqueNumbers = new Set();

    // Добавление элементов
    uniqueNumbers.add(1);
    uniqueNumbers.add(2);
    uniqueNumbers.add(3);
    uniqueNumbers.add(2); // Повторяющийся элемент не добавится

    console.log(uniqueNumbers); // Set(3) { 1, 2, 3 }

    // Проверка наличия элемента
    console.log(uniqueNumbers.has(2)); // true
    console.log(uniqueNumbers.has(5)); // false

    // Удаление элемента
    uniqueNumbers.delete(1);
    console.log(uniqueNumbers); // Set(2) { 2, 3 }

    // Получение размера Set
    console.log(uniqueNumbers.size); // 2

    // Перебор элементов с помощью forEach
    uniqueNumbers.forEach(value => {
      console.log(value);
    });`
},
{
  number: 8,
  title: `Коллекция WeakMap`,
  shortAnswer: '',
  longAnswer: `<strong>WeakMap</strong>
  <span> это специальный вид коллекции в JavaScript, которая хранит пары “ключ-значение”. Однако у неё есть несколько уникальных особенностей, которые отличают её от обычного Map. Основные отличия
  заключаются в том, что WeakMap использует только объекты в качестве ключей и позволяет сборщику мусора автоматически удалять записи, когда на них нет других ссылок.</span><br>
  <strong>Основные характеристики WeakMap</strong><br>
  <strong>1. Ключи могут быть только объектами:</strong><span> ключами могут быть только объекты (например, {}, массивы, функции и т. д.). Примитивные типы, такие как строки или числа, нельзя использовать в качестве ключей.</span><br>
  <strong>2. Слабая ссылка на ключи:</strong><span> это значит, что если на объект-ключ больше нет ссылок в других частях
  программы, он будет удалён сборщиком мусора, и соответствующая запись в WeakMap также будет удалена.</span><br>
  <strong>3. Автоматическая очистка:</strong><span> Записи в WeakMap удаляются автоматически, если на ключ больше нет
  ссылок. Это делает WeakMap полезным для случаев, когда нужно ассоциировать данные с объектами,
  которые могут быть удалены из памяти, например, для реализации кэшей.</span><br>
  <strong>4. Невозможность итерации:</strong><span> Когда объект-ключ становится недоступным (отсутствуют другие ссылки), он автоматически удаляется из WeakMap.</span><br>
  <strong>Методы WeakMap</strong><br>
  <strong>set(key, value)</strong><span> добавляет запись в WeakMap. Если запись с таким ключом уже существует, она будет
  обновлена. Ключом может быть только объект.</span><br>
  <strong>get(key)</strong><span> возвращает значение, связанное с ключом. Если ключ не найден, возвращает undefined.</span><br>
  <strong>has(key)</strong><span> проверяет, существует ли запись с указанным ключом. Возвращает true, если запись
  существует, и false, если нет.</span><br>
  <strong>delete(key)</strong><span> удаляет запись с указанным ключом. Возвращает true, если удаление было успешным, и
  false, если ключ не найден.</span><br>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `const weakMap = new WeakMap();

  let obj1 = { name: "Alice" };
  let obj2 = { name: "Bob" };

  // Добавляем объекты в WeakMap
  weakMap.set(obj1, "Data for Alice");
  weakMap.set(obj2, "Data for Bob");

  console.log(weakMap.get(obj1)); // "Data for Alice"

  obj1 = null; // Объект удаляется, так как больше нет ссылок

  // Спустя некоторое время obj1 будет удалён GC, и его запись исчезнет из WeakMap`
},
{
  number: 9,
  title: `Коллекция WeakSet`,
  shortAnswer: '',
  longAnswer: `<strong>WeakSet</strong>
  <span> это специальный вид коллекции в JavaScript, которая хранит множество объектов и обладает рядом особенностей, которые отличают её от обычного Set. Основные характеристики WeakSet — это
  использование только объектов в качестве значений, слабые ссылки на эти объекты, и автоматическая очистка, если объект больше нигде не используется.</span><br>
  <strong>Основные характеристики WeakSet</strong><br>
  <strong>1. Только объекты в качестве значений:</strong><span> в отличие от обычного Set, в WeakSet можно добавлять
  только объекты. Примитивные значения, такие как строки, числа, или булевы значения, не могут быть элементами WeakSet</span><br>
  <strong>2. Слабые ссылки на объекты:</strong><span> WeakSet хранит слабую ссылку на каждый объект, который добавлен в
  коллекцию. Это означает, что если на объект больше нет других ссылок, он может быть удалён из памяти сборщиком мусора. Таким образом, WeakSet не предотвращает удаление объектов, которые в него добавлены.</span><br>
  <strong>3. Автоматическая очистка:</strong><span> Когда объект удаляется сборщиком мусора (если на него больше нет
  других ссылок), он также автоматически удаляется из WeakSet. Это делает WeakSet полезным для
  отслеживания объектов без необходимости вручную удалять их, когда они больше не нужны.</span><br>
  <strong>4. Нет методов для получения всех элементов или размера:</strong><span> У WeakSet нет методов для итерации
  (forEach, keys, values, entries) и нет свойства size, поскольку в любой момент объекты могут быть
  удалены сборщиком мусора. Это обеспечивает гибкость и экономию памяти, но делает WeakSet менее
  удобным для случаев, когда нужен доступ ко всем элементам.</span><br>
  <strong>Методы WeakSet</strong><br>
  <strong>add(value)</strong><span> добавляет объект в WeakSet. Если объект уже существует в коллекции, WeakSet его не
  добавляет (как и в обычном Set).</span><br>
  <strong>has(value)</strong><span> проверяет, находится ли объект в WeakSet. Возвращает true, если объект существует в
  коллекции, и false, если нет.</span><br>
  <strong>delete(value)</strong><span> удаляет объект из WeakSet. Возвращает true, если объект был успешно удалён, и false,
  если объект не найден в коллекции.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `const weakSet = new WeakSet();

  let user1 = { name: "Alice" };
  let user2 = { name: "Bob" };

  // Добавляем объекты в WeakSet
  weakSet.add(user1);
  weakSet.add(user2);

  console.log(weakSet.has(user1)); // true

  // Удаляем ссылку на user1
  user1 = null;

  // Теперь объект user1 будет удалён из памяти, и WeakSet автоматически очистится
  console.log(weakSet.has(user1)); // false (объект больше не существует)
  `
},
{
  number: 10,
  title: `Function Declaration Function Expression?`,
  shortAnswer: '',
  longAnswer: `<strong>Function Declaration</strong>
  <span> это способ определения функции по ключевому слову Function за которым
  следует имя функции, она всплывает в начало своей области видимости. Это значит что использовать
  функцию можно до ее объявления.</span><br>
  <strong>Как это работает:</strong><br>
  <span>• Когда JavaScript компилирует код, все функции, созданные с помощью function на уровне декларации, поднимаются (hoisted) в начало своей области видимости. Это означает, что функция доступна для вызова до её фактического места в коде.</span><br>
  <span>• Hoisting — это механизм, при котором объявления функций и переменных "поднимаются" в начало области видимости перед выполнением кода.</span><br>
  <span>• Такие функции можно вызывать в любом месте скрипта, даже до строки, где они были определены.</span><br>
  <strong>Function Expression</strong>
  <span> это создание функции в контексте выражения, часто присваиваемого переменной. Это может быть как анонимная функция (без имени), так и именованная.</span><br>
  <strong>Как это работает:</strong><br>
  <span>• Function Expressions создаются как часть выражений и могут быть присвоены переменным, переданы как аргументы в другие функции или возвращены из других функций.</span><br>
  <span>• Такие функции не поднимаются (не проходят через механизм hoisting), а становятся доступными только после выполнения выражени</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Объявление функции
function greet() {
  console.log("Hello, World!");
}

// Вызов функции до её объявления
greet(); // Выведет: "Hello, World!"

// Функциональное выражение
const greet = function() {
  console.log("Hello, World!");
};

// Вызов функции после её объявления
greet(); // Выведет: "Hello, World!"
  `
},
{
  number: 11,
  title: `Различие между стрелочной и обычной Функцией ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>1. Cинтаксис</strong><br>
  <strong>2. Поднятие (hoisting)</strong><br>
  <span>Обычные функции, объявленные как <b>Function Declaration</b>, поднимаются, то есть они могут быть
  вызваны до своего объявления.</span><br>
  <span>Стрелочные функции всегда являются <b>Function Expression</b>, поэтому не поднимаются и их можно
  вызывать только после объявления.</span><br>
  <strong>3. Контекст this</strong><br>
  <span><b>Обычные функции</b> имеют собственный контекст this, который определяется в момент вызова
  функции. Значение this зависит от того, как и где была вызвана функция (например, как метод объекта,
  как функция-конструктор или просто как функция).</span><br>
  <span><b>Стрелочные функции</b> не имеют собственного this. Они наследуют this из внешней области, в которой
  были объявлены. Это делает их удобными в случаях, когда нужно использовать тот же контекст this
  внутри вложенных функций.</span><br>
  <strong>4. Использование в качестве конструктора</strong><br>
  <span><b>Обычные функции</b> могут быть вызваны с помощью оператора new, создавая новый экземпляр
  объекта. Функции-конструкторы позволяют задавать свойства для новых объектов через this.</span><br>
  <span><b>Стрелочные функции</b> не могут быть использованы как конструкторы.</span><br>
  <strong>5. Отсутствие объекта arguments у стрелочных функций</strong>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 12,
  title: `Методы сравнения в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Не строгое равенство ==</strong><br>
  <span>сравнивает значения с приведением типов. Это значит, что перед сравнением JavaScript может преобразовать типы, чтобы они совпали.</span><br>
  <strong>Строгое равенство ===</strong><br>
  <span>сравнивает значения без приведения типов. Типы должны совпадать, иначе результат будет false.</span><br>
  <strong>Object.is()</strong><br>
  <span>Метод Object.is() проверяет два значения на равенство, почти как ===, но с некоторыми отличиями.
  Например, Object.is() считает +0 и -0 разными значениями, а NaN равен самому себе.</span><br>
  <strong>Сравнение объектов и массивов</strong><br>
  <span>В JavaScript объекты и массивы сравниваются по ссылке, а не по значению. Поэтому два объекта будут равны, только если они ссылаются на один и тот же объект в памяти.</span><br>
  <strong>Number.isNaN(value)</strong><br>
  <span>Предназначен для проверки является ли значение именно NaN, и отличается от глобальной функции
  isNaN() тем что он работает более строго и надежно.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Пример использования == и ===
  console.log(5 == "5");   // true
  console.log(5 === "5");  // false

  console.log(0 == false); // true
  console.log(0 === false); // false
  console.log(Object.is(5, 5));      // true
  console.log(Object.is(5, "5"));    // false
  console.log(Object.is(NaN, NaN));  // true
  console.log(Object.is(+0, -0));   // false
`
},
{
  number: 13,
  title: `Что такое замыкание ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Замыкание в JavaScript</strong><br>
  <span>это механизм, который позволяет функции "запомнить" своё лексическое окружение (среду), в котором она была создана, даже после того, как выполнение этого окружения завершилось. То есть, замыкание позволяет функции доступ к переменным из внешней функции, в которой она 
  была определена, даже если эта внешняя функция уже завершила выполнение.</span><br>
  <span>Замыкания являются важной концепцией в JavaScript, так как они позволяют создавать функции с приватными данными и сохранять состояние между вызовами функций.</span><br>
  <strong>Зачем это нужно?</strong><br>
  <span>• Создания приватных переменных: Когда вы хотите, чтобы переменные были недоступны напрямую из внешнего кода, но доступны через функции.</span><br>
  <span>• Функции с состоянием: Замыкания могут хранить состояние между вызовами.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function createCounter() {
  let count = 0; // Приватная переменная

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();

counter.increment(); // 1
counter.increment(); // 2
counter.decrement(); // 1
console.log(counter.getCount()); // 1 (получаем приватное состояние)`
},
{
  number: 14,
  title: `Делегирование событий ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Делегирование событий в JavaScript</strong><br>
  <span>это подход, при котором событие не привязывается непосредственно к каждому элементу, а к общему родительскому элементу. Когда событие происходит на дочернем элементе, 
  оно "всплывает" вверх по дереву DOM, и родительский элемент может перехватить его и обработать. 
  Это особенно полезно, когда вам нужно обрабатывать события для множества элементов, а не привязывать обработчики для каждого из них.</span><br>
  <strong>Как работает делегирование событий</strong><br>
  <span>При использовании делегирования событий мы устанавливаем один обработчик на родительский
  элемент. Затем, когда событие происходит на одном из дочерних элементов, оно всплывает вверх по
  DOM (механизм, называемый всплытием событий), и обработчик на родителе перехватывает его. В этом
  обработчике можно проверить, на каком именно дочернем элементе произошло событие, и выполнить
  соответствующие действия</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `<div id="buttonContainer">
  <button class="action-button">Button 1</button>
  <button class="action-button">Button 2</button>
  <button class="action-button">Button 3</button>
  <button class="action-button">Button 4</button>
</div>

// Получаем родительский элемент (div)
const buttonContainer = document.getElementById('buttonContainer');

// Используем делегирование событий
buttonContainer.addEventListener('click', function(e) {
  // Используем .closest() для поиска кнопки, на которую кликнули
  const button = e.target.closest('.action-button');

  if (button) {
    // Меняем стиль кнопки при клике
    button.style.backgroundColor = 'yellow';
    button.style.fontWeight = 'bold';
  }
});
`
},
{
  number: 15,
  title: `Атрибуты async и defer ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Атрибут async</strong><br>
  <span>Атрибут async указывает браузеру загружать скрипт асинхронно. Когда браузер обнаруживает скрипт
  с этим атрибутом, он загружает его параллельно с остальной частью страницы. После загрузки скрипт сразу выполняется, даже если HTML еще не завершил загрузку.</span><br>
  <strong>Особенности async:</strong><br>
  <span>• Загрузка происходит параллельно с HTML.</span>
  <span>• Выполнение скрипта происходит сразу после завершения загрузки, что может прервать 
  парсинг HTML.</span>
  <span>• Порядок выполнения не гарантируется, если несколько скриптов имеют атрибут async.</span>
  <strongАтрибут defer</strong>
  <span>Атрибут defer также загружает скрипт параллельно с HTML, но откладывает его выполнение до полной
  загрузки и парсинга HTML-документа. Скрипты с defer выполняются в порядке, в котором они указаны
  на странице.</span><br>
  <strong>Особенности defer:</strong><br>
  <span>• Загрузка происходит параллельно с HTML.</span>
  <span>• Выполнение происходит только после полной загрузки HTML, что позволяет избежать блокировки парсинга страницы.</span>
  <span>• Порядок выполнения гарантирован, что делает defer удобным для скриптов, зависящих от DOM или других скриптов.</span>
  <span>• document.addEventListener("DOMContentLoaded", function() {console.log("DOM полностью загружен и разобран.");</span>`,
  frequency: 4,
  language: "html",
  codeExample: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Async vs Defer Example</title>
</head>
<body>
  <h1>Пример использования async и defer</h1>

  <!-- Сценарий с атрибутом async -->
  <script async src="async-script.js"></script>

  <!-- Сценарий с атрибутом defer -->
  <script defer src="defer-script.js"></script>

  <p>Текст страницы...</p>
</body>
</html>
`
},
{
  number: 16,
  title: `Асинхронность в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Асинхронность</b> в JavaScript помогает выполнять задачи, которые могут занять длительное время, не
  блокируя главный поток выполнения программы. JavaScript работает в одном потоке, и поэтому, когда
  выполняется длительная операция (например, загрузка данных с сервера), необходимо использовать
  асинхронные методы, чтобы интерфейс приложения оставался отзывчивым и не зависал. Основные
  механизмы для работы с асинхронностью в JavaScript — это <b>колбэки (callbacks)</b>, <b>промисы (promises)</b> и
  <b>асинхронные функции (async/await)</b>.</span><br>
  <strong>1. Callbacks</strong><span> это функции, которые передаются как аргументы в другую функцию и вызываются после
  завершения этой функции. В старых версиях JavaScript колбэки были основным способом обработки
  асинхронности, но они часто приводили к так называемому “аду колбэков” (callback hell), когда код
  становился трудно читаемым из-за вложенных функций.</span><br>
  <strong>2. Промисы</strong><span> это объекты, представляющие результат асинхронной операции. Они могут находиться в
  одном из трёх состояний:</span><br>
  <span>• <b>pending (ожидание)</b> — операция ещё не завершена.</span><br>
  <span>• <b>fulfilled (выполнено)</b> — операция успешно завершена.</span><br>
  <span>• <b>rejected (отклонено)</b> — операция завершилась с ошибкой.</span><br>
  <strong>3. Async/Await</strong><span> это синтаксический сахар над промисами, позволяющий писать асинхронный код,
  который выглядит как синхронный. Функции, объявленные с async, возвращают промис,
  а ключевое слово await заставляет интерпретатор JavaScript ждать выполнения промиса.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Функция с callback
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: 'John', age: 30 };
    callback(null, data); // Успешный ответ
  }, 1000);
}

// Вызов с callback
fetchData((error, data) => {
  if (error) {
    console.log('Ошибка:', error);
  } else {
    console.log('Данные с использованием Callback:', data);
  }
});




// Функция с Promise
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { name: 'John', age: 30 };
      resolve(data); // Успешный ответ
    }, 1000);
  });
}

// Вызов с Promise
fetchData()
  .then(data => {
    console.log('Данные с использованием Promise:', data);
  })
  .catch(error => {
    console.log('Ошибка:', error);
  });




  // Функция с async/await
async function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { name: 'John', age: 30 };
      resolve(data); // Успешный ответ
    }, 1000);
  });
}

// Вызов с async/await
async function getData() {
  try {
    const data = await fetchData();
    console.log('Данные с использованием async/await:', data);
  } catch (error) {
    console.log('Ошибка:', error);
  }
}

getData();

`
},
{
  number: 17,
  title: `Что такое EventLoop ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Event Loop (событийный цикл)</strong><br>
  <span>это механизм, который позволяет JavaScript выполнять асинхронные операции и управлять многими задачами, не блокируя основной поток выполнения. Понимание событийного цикла имеет ключевое значение для понимания асинхронного программирования в JavaScript, так как это объясняет, как обрабатываются события и выполняются колбэки.</span><br>
  <strong>Основные компоненты Event Loop</strong><br>
  <span><b>1. Call Stack (Стек вызовов):</b> Это структура данных, которая хранит контекст выполнения текущего кода. Когда вызывается функция, она добавляется в стек, и когда функция завершается, она удаляется из стека. Если стек пуст, значит, нет выполняющегося кода.</span><br>
  <span><b>2. Web APIs:</b> Это API, предоставляемые браузером (или средой выполнения, такой как Node.js), которые
  позволяют выполнять асинхронные операции, такие как HTTP-запросы, таймеры и т. д. Эти операции
  выполняются вне стека вызовов.</span><br>
  <span><b>3. Очередь макротасок:</b> куда попадают задачи от web API</span><br>
  <span><b>4. Очередь микротасок:</b> куда попадают задачи от промисов</span><br>
  <strong>Алгоритм работы Event Loop</strong><br>
  <span>1. Выполняются все синхронные задачи. Задачи от WebAPI отдаются на выполнение браузеру</span><br>
  <span>2. Выполняются все задачи из очереди микротасок (пока очередь не опустеет)</span><br>
  <span>3. Выполняется одна задача из очереди макротасок</span><br>
  <span>4. Производится рендеринг</span><br>
  <span>5. Цикл повторяется</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `console.log('1'); // Выводим в консоль "1"

// Таймаут (макротаск)
setTimeout(() => {
  console.log('2'); // Выводим в консоль "2"
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // Выводим в консоль "3"
}).then(() => {
  console.log('4'); // Выводим в консоль "4"
});

console.log('5'); // Выводим в консоль "5"`
},
{
  number: 18,
  title: `Не мутирующие методы массивов ?`,
  shortAnswer: '',
  longAnswer: `
  <span>Метод <b>map</b> создаёт новый массив, заполняя его результатами вызова заданной функции для каждого элемента исходного массива.</span><br>
  <span>Метод <b>filter</b> создаёт новый массив, содержащий все элементы, которые прошли проверку, заданную в функции.</span><br>
  <span>Метод <b>forEach</b> выполняет указанную функцию один раз для каждого элемента массива. Он не возвращает новый массив.</span><br>
  <span>Метод <b>slice</b> создает новый массив, содержащий копию части исходного массива, не изменяя его.</span><br>
  <span>Метод <b>reduce</b> создает новое значение (не массив) на основе всех элементов массива, используя функцию редукции. Однако этот метод не изменяет исходный массив.</span><br>
  <span>Метод <b>every</b> проверяет, удовлетворяют ли все элементы массива условию, заданному в функции, и возвращает true или false.</span><br>
  <span>Метод <b>some</b> проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции,и возвращает true или false.</span><br>
  <strong>Немутирующие методы массивов позволяют работать с данными, создавая новые массивы или значения без изменения исходных массивов. Это важно для обеспечения предсказуемости и упрощения отладки кода, особенно в функциональном программировании.</strong>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Массив строк
  const words = ['apple', 'banana', 'cherry'];

    // Используем map для преобразования строк в верхний регистр
  const upperCaseWords = words.map(word => word.toUpperCase());

  console.log(upperCaseWords); // ['APPLE', 'BANANA', 'CHERRY']
  `
},
{
  number: 19,
  title: `Мутирующие методы массивов ?`,
  shortAnswer: '',
  longAnswer: `
  <span>Метод <b>push()</b> добавляет один или несколько элементов в конец массива и возвращает новую длину
  массива.</span><br>
  <span>Метод <b>pop()</b> удаляет последний элемент массива и возвращает его. Если массив пуст, возвращает
  undefined.</span><br>
  <span>Метод <b>shift()</b> удаляет первый элемент массива и возвращает его. Если массив пуст, возвращает
  undefined.</span><br>
  <span>Метод <b>unshift()</b> добавляет один или несколько элементов в начало массива и возвращает новую длину
  массива.</span><br>
  <span>Метод <b>splice()</b> позволяет добавлять, удалять или заменять элементы в массиве. Этот метод
  универсален, но несколько сложен в использовании.</span><br>
  <span>Метод <b>sort()</b> сортирует элементы массива на месте и возвращает отсортированный массив. По
  умолчанию сортирует строки в лексикографическом порядке. Для чисел или других объектов часто
  требуется передать функцию сравнения.</span><br>
  <span>Метод <b>reverse()</b> переворачивает массив, изменяя порядок элементов на обратный.</span><br>
  <span>Метод <b>fill()</b> заполняет все элементы массива указанным значением с начального индекса до конечного.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Исходный массив
let fruits = ['apple', 'banana', 'cherry'];

// Используем push() — добавляем элемент в конец массива
fruits.push('orange');
console.log(fruits); // ['apple', 'banana', 'cherry', 'orange']

// Используем pop() — удаляем последний элемент массива
let lastFruit = fruits.pop();
console.log(fruits); // ['apple', 'banana', 'cherry']
console.log('Удаленный фрукт:', lastFruit); // 'orange'

// Используем shift() — удаляем первый элемент массива
let firstFruit = fruits.shift();
console.log(fruits); // ['banana', 'cherry']
console.log('Удаленный фрукт:', firstFruit); // 'apple'

// Используем unshift() — добавляем элемент в начало массива
fruits.unshift('strawberry');
console.log(fruits); // ['strawberry', 'banana', 'cherry']

// Используем splice() — удаляем или добавляем элементы в произвольном месте массива
fruits.splice(1, 1, 'blueberry', 'mango');
console.log(fruits); // ['strawberry', 'blueberry', 'mango', 'cherry']
  `
},
{
  number: 20,
  title: `Мeтоды event.preventDeafolt(), evenet.stopPropagination()
  для чего нужны ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>event.preventDefault()</strong><br>
  <span>Этот метод предотвращает выполнение стандартного действия, связанного с событием. Например, если вы нажимаете на ссылку (<code>&lt;a&gt;</code>), браузер обычно переходит по указанному URL. Если вы вызовете event. preventDefault() в обработчике события клика по этой ссылке, переход не произойдёт.</span><br>
  <strong>event.stopPropagation()</strong><br>
  <span>Этот метод останавливает всплытие события, предотвращая его дальнейшую передачу вверх по дереву DOM. В JavaScript события могут “всплывать” от целевого элемента к родительским элементам. Если вы хотите, чтобы событие не доходило до родительских элементов, вы можете использовать event.stopPropagation().</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `document.getElementById('myForm').addEventListener('submit', function(event) {
  event.preventDefault(); // Предотвращаем стандартную отправку формы
  alert('Форма не отправлена!');
  });

  document.getElementById('menu').addEventListener('click', function(event) {
  event.stopPropagation(); // Меню не закроется при клике внутри него
});

document.body.addEventListener('click', function() {
  document.getElementById('menu').style.display = 'none';
});
  `
},
{
  number: 21,
  title: `Что такое DOM-дерево ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>DOM-дерево (Document Object Model)</strong>
  <span>это программный интерфейс для HTML и XML документов. Оно представляет документ в виде дерева узлов, где каждый узел является объектом, с которым можно взаимодействовать при помощи JavaScript. DOM предоставляет методы и свойства для динамического изменения структуры, стилей и содержания документа.</span><br>
  <strong>Структура DOM-дерева</strong><br>
  <span>Корневой элемент: Веб-страница начинается с корневого элемента, который обычно является элементом <html> в HTML-документе.</span><br>
  <strong>Узлы:</strong><br>
  <span>Каждый элемент, атрибут, текст или комментарий в документе представляется как узел. Узлы могут быть разных типов:</span><br>
  <span>• Элемент (Element node): Узел, представляющий HTML-тег (например, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>).</span><br>
  <span>• Текст (Text node): Узел, содержащий текст внутри элемента.</span><br>
  <span>• Атрибут (Attribute node): Узел, представляющий атрибут элемента (например, class, id).</span><br>
  <span>• Комментарий (Comment node): Узел, представляющий комментарий в коде.</span><br>
  <strong>Иерархия:</strong><span> узлы в DOM-дереве организованы в иерархическую структуру. Каждый элемент может
  содержать дочерние элементы, что создает древовидную структуру.</span><br>
  <strong>DOM-дерево</strong><span> это важный концепт в веб-разработке, позволяющий динамически изменять веб-страницы. Понимание структуры и работы DOM позволяет разработчикам создавать интерактивные и динамичные веб-приложения.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 22,
  title: `Что такое всплытие события ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Всплытие события (event bubbling)</strong>
  <span>это механизм в JavaScript, который описывает, как события, происходящие на элементе, поднимаются (всплывают) вверх по дереву DOM к родительским элементам.
  Этот процесс происходит в иерархической структуре документа, и он позволяет родительским элементам реагировать на события, происходящие на их дочерних элементах.</span><br>
  <strong>Как это работает</strong><br>
  <span>Когда событие происходит на элементе (например, клик по кнопке), оно сначала обрабатывается этим элементом. Затем событие “всплывает” вверх к родительскому элементу, и если родитель имеет
  обработчик этого события, он также будет выполнен. Этот процесс продолжается до тех пор, пока событие не достигнет корневого элемента документа (обычно это элемент <code>&lt;html&gt;</code>).</span><br>
  <strong>Всплытие события</strong><br>
  <span>это мощный механизм, который позволяет создавать гибкую обработку событий в JavaScript. Он позволяет родительским элементам реагировать на события своих дочерних элементов,
  что упрощает структуру кода и уменьшает количество обработчиков, необходимых для каждого элемента.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 23,
  title: `Что такое функция высшего порядка ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Функция высшего порядка</strong>
  <span>это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как результат. В JavaScript функции высшего порядка широко используются для абстрагирования операций, таких как итерации, фильтрация, создание замыканий и управление асинхронным кодом.</span><br>
  <strong>Примеры функций высшего порядка</strong><br>
  <span>1. Например, метод массива map является функцией высшего порядка, так как он принимает функцию в качестве аргумента для обработки каждого элемента массива.</span><br>
  <span>2. Функция высшего порядка может возвращать другую функцию. Это позволяет создавать замыкания и настраиваемые функции.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 24,
  title: `Что такое чистая функция ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Чистая функция</strong>
  <span>это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов. Чистые функции являются ключевой концепцией
  в функциональном программировании, так как они делают код более предсказуемым и легко тестируемым.</span><br>
  <strong>Свойства чистых функций</strong><br>
  <span><b>1. Детерминированность:</b> Чистая функция всегда возвращает один и тот же результат, если ей переданы одинаковые аргументы. Например, функция, которая только складывает два числа, будет всегда возвращать одно и то же значение для одних и тех же чисел.</span><br>
  <span><b>2. Отсутствие побочных эффектов:</b> Чистая функция не изменяет внешние состояния, такие как глобальные переменные, значения аргументов или состояния объектов. Она работает только с данными, переданными ей, и не влияет на что-либо за её пределами.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function doubleArray(arr) {
  return arr.map(num => num * 2);
}

const numbers = [1, 2, 3];
console.log(doubleArray(numbers)); // [2, 4, 6]
console.log(numbers); // [1, 2, 3] (исходный массив не изменился)
 `
},
{
  number: 25,
  title: `Функция debounce ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Debounce</strong>
  <span>это функция, которая ограничивает частоту вызова другой функции, обеспечивая, что она будет выполнена только после того, как определенный период времени прошел с момента последнего вызова. Это особенно полезно в ситуациях, когда вы хотите предотвратить выполнение функции, которая может вызываться слишком часто, например, при прокрутке страницы, изменении размеров окна или вводе текста в поле.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function debounce(func, delay) {
  let timeout;

  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
}

  // Использование: функция, которая вызывается не чаще, чем раз в 500 мс
  function onSearch(query) {
  console.log("Поиск: " + query);
}

const debouncedSearch = debounce(onSearch, 500);

// Имитация ввода текста (каждый ввод сбрасывает таймер)
debouncedSearch("Hello");
debouncedSearch("Hello, Wo");
debouncedSearch("Hello, World"); // Только этот вызов сработает через 500 мс
 `
},
{
  number: 26,
  title: `В чем отличие package.json и package-lock.json ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>package.json и package-lock.json</strong>
  <span>это файлы, используемые в Node.js для управления зависимостями проекта. Хотя они оба связаны с зависимостями, они имеют разные назначения и работают по-разному.</span><br>
  <strong>package.json</strong>
  <span>это основной файл конфигурации проекта, который: Содержит информацию о проекте: его название, версию, авторов и лицензии.Описывает зависимости, которые необходимы для запуска и разработки проекта. Хранит данные о версиях пакетов, которые подходят для проекта, но не фиксирует точные версии. Управляет скриптами, командами, которые могут запускаться через npm или yarn, например, npm start, npm test.</span><br>
  <strong>package-lock.json</strong><br>
  <span>это файл, автоматически создаваемый при установке пакетов с помощью npm или yarn, который:</span><br>
  <span>• Фиксирует точные версии всех установленных пакетов, включая подзависимости (зависимости
  зависимостей).</span><br>
  <span>• Обеспечивает консистенцию и предсказуемость установки пакетов на разных машинах. Это особенно
  полезно в команде, где всем разработчикам и серверам нужна одинаковая версия каждой зависимости.</span><br>
  <span>• Обновляется при установке новых зависимостей, удалении или изменении версии уже установленных пакетов.</span><br>
  <span>• Не должен редактироваться вручную — изменения вносятся через команды npm или yarn.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 27,
  title: `Оператор Optional chaining - знак вопроса, что это ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Оператор Optional chaining (?.)</strong>
  <span>это удобный способ безопасно обращаться к вложенным свойствам объектов, которые могут быть null или undefined. Он позволяет избежать ошибок, когда вы пытаетесь получить доступ к свойству, которого может не существовать.</span><br>
  <strong>Как работает Optional chaining</strong><br>
  <span>это удобный способ безопасно обращаться к вложенным свойствам Оператор ?. проверяет, существует ли значение слева от него, и если это значение не null и не undefined, то возвращает следующее свойство. Если же значение null или undefined, то возвращает undefined и останавливает дальнейшее выполнение (не выбрасывает ошибку).</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `const user = {
  name: "Александр",
  address: {
    city: "Москва",
  },
};

console.log(user.name); // "Александр"
console.log(user.address.city); // "Москва"
console.log(user.address?.street); // undefined (без ошибки!)`
},
{
  number: 28,
  title: `Утечки памяти в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Утечки памяти в JavaScript</strong>
  <span>возникают, когда динамически выделенная память перестаёт
  использоваться, но не освобождается должным образом, и остаётся «захваченной» в программе, даже
  если она больше не нужна. Это может приводить к замедлению работы приложения и к значительному
  увеличению его объёма в памяти, особенно в долгоживущих приложениях, таких как веб-приложения с
  множеством взаимодействий и обновлений.</span><br>
  <span>Вот несколько ключевых аспектов, которые помогут понять, что вызывает утечки памяти в JavaScript, и
  как их можно предотвратить:</span><br>
  <strong>Как JavaScript управляет памятью</strong>
  <span>JavaScript использует сборщик мусора (garbage collector), который автоматически освобождает память,
  занимаемую переменными, когда они больше не используются. Сборщик мусора работает по принципу
  достижимости объектов, то есть если объект не может быть достигнут (например, у него нет ни одного
  ссылки), то он считается ненужным и может быть удалён из памяти.</span><br>
  <strong>Основные причины утечек памяти в JavaScript</strong><br>
  <strong>1. Замыкания</strong>
  <span>Позволяют функции запоминать своё окружение и доступ к переменным, определённым
  вне её тела. Если замыкание захватывает переменные, которые больше не используются, и эта функция продолжает ссылаться на них, они остаются в памяти. Особенно это может быть проблемой, если замыкание остаётся в памяти из-за ссылок на него, например, в DOM-элементах или таймерах.</span><br>
  <strong>2. Незавершённые таймеры и обработчики событий</strong>
  <span>Если вы используете setInterval или setTimeout, но не отменяете их с помощью clearInterval или
  clearTimeout, функции, к которым они ссылаются, будут продолжать храниться в памяти. Это также
  относится к слушателям событий, которые не удаляются с элементов после их создания.</span><br>
  <strong>3. Кэширование данных</strong>
  <span>Использование больших структур данных, например, массивов или объектов, для кэширования данных
  (например, результаты API-запросов или промежуточные вычисления) может привести к накоплению
  ненужных объектов в памяти, если старые данные не очищаются. Особенно это критично для
  одностраничных приложений, где данные кэшируются на длительное время.</span><br>
  <strong>4. Глобальные переменные и незавершённые ссылки</strong>
  <span>Глобальные переменные остаются в памяти до конца жизни программы, так как сборщик мусора
  не может освободить их. Похожая проблема может возникнуть, если переменные определяются в
  замыкании и остаются доступными для вызова, даже если они больше не нужны.</span><br>
  <strong>Как найти утечки памяти</strong><br>
  <span><b>1. Использование DevTools:</b> Chrome, имеют вкладку Performance и Memory, которые позволяют отслеживать использование памяти.</span><br>
  <span><b>2. Мониторинг количества объектов и DOM-элементов:</b> Если количество объектов или DOM-элементов растёт после выполнения действий (например, после многократного открытия и закрытия модального окна), это может указывать на утечку памяти.</span><br>
  <span><b>3. Снимки кучи (Heap Snapshots):</b> В DevTools можно сделать снимки кучи памяти до и после выполнения некоторых действий и сравнить их, чтобы увидеть, какие объекты остаются в памяти.</span><br>`,
  frequency: 4,
  language: "javascript",
}
]

export const BROWSER_NETWORKS = [
  {
    number: 1,
    title: `Что происходит в браузере после того как мы вводим url страницы ?`,
    shortAnswer: '',
    longAnswer: `
    <strong>1. Ввод URL и определение протокола</strong>
    <span>Когда мы вводим URL, браузер распознает протокол (например, http://, https://), доменное имя и путь. Это
    помогает браузеру понять, какой метод доступа будет использован для запроса к серверу.(метод GET).</span><br>
    <strong>2. Проверка кеша</strong>
    <span>Браузер сначала проверяет кешированные данные:
    Кеш браузера: может содержать файлы (HTML, CSS, JS), которые были загружены ранее.
    DNS-кеш: содержит информацию о ранее посещенных доменах и их IP-адресах.
    Кеш промежуточных серверов: такие как CDN или прокси-сервера.
    Если браузер находит кешированную копию запрашиваемой страницы, и эта копия является актуальной, он может сразу отобразить страницу, минуя запрос к серверу.</span><br>
    <strong>3. DNS-резолвинг</strong>
    <span>Если в кеше нет данных о домене, начинается процесс резолвинга DNS. Сначала браузер обращается
    к DNS-серверу, чтобы преобразовать доменное имя (например, example.com) в IP-адрес, связанный с сервером, который обслуживает данный домен. DNS-запрос проходит через несколько уровней:
    Локальный DNS-кеш: хранит записи DNS, если они использовались недавно. DNS-сервер провайдера: сервер интернет-провайдера может хранить кешированные DNS-записи. Корневые DNS-серверы: если IP не найден локально, запрос переходит к серверам, которые управляют доменами верхнего уровня (.com, .ru и т.д.).</span><br>
    <strong>4. Установление соединения</strong>
    <span>После получения IP-адреса браузер начинает устанавливать соединение с сервером. TCP-соединение: браузер и сервер выполняют трехэтапное рукопожатие (3-way handshake), чтобы установить соединение и обеспечить надежность передачи данных. TLS/SSL (если используется HTTPS): браузер и сервер начинают процесс шифрования с помощью TLS/SSL. Они обмениваются ключами, проверяют сертификаты безопасности, чтобы шифровать и защищать передаваемые данные.</span><br>
    <strong>5. Отправка HTTP-запроса</strong>
    <span>После установления соединения браузер отправляет HTTP-запрос на сервер.
    Запрос включает:
    • Метод HTTP (например, GET, POST).
    • Заголовки: информация о браузере, сессии, cookies и т.д.
    • Тело запроса (для POST, PUT запросов).</span><br>
    <strong>6. Обработка запроса на сервере</strong>
    <span>Сервер получает запрос, выполняет необходимые действия (например, запускает программу на сервере для генерации динамического контента или ищет нужный файл) и формирует HTTP-ответ.
    • Статус-код (например, 200 OK, 404 Not Found).
    • Заголовки: тип содержимого, размер, кеширование, cookies и т.д.
    • Тело ответа: HTML-код страницы, данные JSON и т.д.</span><br>
    <strong>7. Получение и обработка HTTP-ответа</strong>
    <span>Браузер получает ответ и проверяет статус-код. Если всё в порядке (например, 200 OK), он начинает разбирать контент страницы, определяя тип содержимого (обычно это HTML).</span><br>
    <strong>8. Парсинг HTML и построение DOM-дерева</strong>
    <span>Браузер начинает парсинг HTML и создает DOM-дерево. DOM (Document Object Model) представляет
    структуру HTML-документа в виде дерева узлов, где каждый узел — это HTML-элемент или текстовый
    узел.</span><br>
    <strong>9. Загрузка и выполнение CSS и JavaScript</strong>
    <span>В процессе построения DOM браузер находит внешние ресурсы, такие как CSS, JavaScript и изображения, и загружает их. <b>CSS:</b> создается CSSOM (CSS Object Model), который вместе с DOM формирует Render Tree, где указаны стили для каждого элемента.
    <b>JavaScript:</b> JS-файлы загружаются и выполняются. Если JavaScript изменяет DOM, браузер обновляет
    дерево DOM. Некоторые скрипты могут блокировать отображение страницы до их выполнения.</span><br>
    <strong>10. Построение и рендеринг Render Tree</strong>
    <span>Браузер объединяет DOM и CSSOM в Render Tree, которое включает только видимые элементы. Это дерево нужно для рендеринга элементов на экране.</span><br>
    <strong>11. Расчёт расположения элементов (Layout)</strong>
    <span>На основе Render Tree браузер рассчитывает точное расположение каждого элемента на странице — этот процесс называется Layout.</span><br>
    <strong>12. Отображение на экране (Painting)</strong>
    <span>Наконец, браузер выполняет отрисовку (Painting), когда каждый элемент получает свои стили и позиции на экране. Графический процессор (GPU) может использоваться для обработки сложных элементов и анимаций.</span><br>
    <strong>Дополнительные процессы</strong>
    <span>Асинхронная загрузка ресурсов: такие ресурсы, как изображения, видео, и асинхронные скрипты загружаются и выполняются параллельно. Оптимизация: браузер может выполнять оптимизации для ускорения загрузки и рендеринга страниц (например, lazy loading, кэширование, оптимизация отрисовки).</span>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 2,
    title: `Разница между HTTP/1.1, HTTP/2, и HTTP/3 ?`,
    shortAnswer: '',
    longAnswer: `
    <strong>HTTP/1.1 (1997)</strong><br>
    <strong>Основные особенности:</strong>
    <span>Последовательные запросы — каждое соединение обслуживает только один запрос за раз.
    <b>Keep-Alive</b> — позволяет использовать одно соединение для нескольких запросов.
    <b>Pipelining (не прижился)</b> — возможность отправлять несколько запросов без ожидания ответов, но сервера редко поддерживали его из-за сложностей.
    <b>Текстовый формат</b> — заголовки отправляются в текстовом виде, что занимает много места.</span><br>
    <strong>HTTP/2 (2015)</strong><br>
    <strong>Что улучшилось:</strong>
    <span><b>Мультиплексирование</b> — несколько запросов выполняются одновременно в одном TCP-соединении.
    <b>Бинарный формат</b> — данные передаются в компактном виде, что снижает объем передаваемых заголовков.
    <b>Сжатие заголовков (HPACK)</b> — уменьшает размер передаваемых данных.
    <b>Server Push</b> —  сервер может отправлять ресурсы клиенту заранее (например, CSS и JS).</span><br>
    <strong>HTTP/3 (2022)</strong><br>
    <strong>Что улучшилось:</strong>
    <span><b>QUIC</b> вместо <b>TCP</b> — каждый запрос обрабатывается независимо, нет общей блокировки.
    <b>Шифрование по умолчанию</b> (TLS 1.3) — защищает передаваемые данные.
    <b>Меньшие задержки</b> (low latency) — быстрее устанавливается соединение.
    <b>Работает лучше при потере пакетов</b> — повторная передача касается только потерянных данных, а не всего потока.</span>
    `,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 3,
    title: `Что такое политика безопасности CORSE`,
    shortAnswer: '',
    longAnswer: `
    <strong>CORS (Cross-Origin Resource Sharing)</strong><br>
    <strong>Основные особенности:</strong> <span>это политика безопасности, реализованная в браузерах для защиты пользователей от злоумышленников. Она предотвращает выполнение запросов с одного источника (домена) к ресурсам на другом, если они не разрешены, так как браузеры по умолчанию блокируют такие запросы.</span><br>
    <strong>Как работает CORS?</strong><br>
    <span>CORS добавляет HTTP-заголовки к ответу сервера, разрешая доступ к ресурсам для определенных источников. Эти заголовки говорят браузеру, что запросы с других доменов безопасны и могут быть выполнены.</span><br>
    <strong>Основные заголовки CORS:</strong><br>
    <span><b>Access-Control-Allow-Origin</b> — указывает, каким источникам разрешен доступ.</span><br>
    <span><b>Access-Control-Allow-Origin: *</b> — доступ разрешен всем.</span><br>
    <span><b>Access-Control-Allow-Origin: https://example.com</b> — доступ разрешен только указанному источнику.</span><br>
    <span><b>Access-Control-Allow-Methods</b> — разрешенные HTTP-методы, например, GET, POST, PUT, DELETE.</span><br>
    <span><b>Access-Control-Allow-Headers</b> — список заголовков, которые клиент может использовать.</span><br>
    <span><b>Access-Control-Allow-Credentials</b> — позволяет отправлять куки и заголовки авторизации.</span><br>
    <span><b>Preflight-запрос</b> — При использовании методов, отличных от GET или POST, или при отправке нестандартных заголовков, браузер отправляет предварительный запрос (preflight). Это запрос OPTIONS, чтобы проверить, разрешены ли такие действия. Если сервер возвращает нужные заголовки, основной запрос выполняется.</span><br>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 4,
    title: `Как работает mode: 'no-cors'?`,
    shortAnswer: '',
    longAnswer: `<span>Когда запрос отправляется с параметром mode: <b>'no-cors'</b>, браузер не выполняет preflight-запрос, и поэтому:</span><br>
    <span>• Браузер разрешает отправку только некоторых типов запросов, например, <b>GET</b> и <b>POST</b>, с ограниченным набором заголовков.</span><br>
    <span>• Доступ к ответу от сервера сильно ограничен. Вы не сможете получить содержимое тела ответа или заголовки, потому что они будут заблокированы.</span><br>
    <span>• <b>mode: 'no-cors'</b> подходит только для случаев, когда не требуется обработка ответа от сервера в браузере (например, при отправке аналитических данных на сторонний сервер).</span><br>
    <strong>Когда использовать mode: 'no-cors'?</strong>
    <span>Этот режим подходит для простых, односторонних запросов, например: Отправка данных для аналитики: когда важно только отправить данные, но не требуется получать ответ.
    Встраивание сторонних ресурсов: иногда mode: 'no-cors' используется для подключения внешних скриптов или изображений в браузере, не нарушая политики безопасности.</span><br>`,
    frequency: 4,
    language: "javascript",
    codeExample: `fetch('https://example.com/data', {
method: 'POST',
mode: 'no-cors',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify({ name: 'Alice' })
})
.then(response => {
// response будет пустым из-за режима 'no-cors'
console.log(response); // Не получится получить тело ответа или
заголовки
})
.catch(error => console.error('Ошибка:', error));`
  },
  {
    number: 5,
    title: `Что такое REST ?`,
    shortAnswer: '',
    longAnswer: `
    <strong>REST (Representational State Transfer)</strong><br><span>это архитектурный стиль для разработки веб-сервисов, который позволяет клиентам и серверам взаимодействовать через сеть, используя простой и понятный набор операций. REST широко применяется для построения API, которые позволяют приложениям обмениваться данными и функциональностью по HTTP.</span><br>
    <strong>Основные принципы REST:</strong><br>
    <span><b>Клиент-серверная архитектура:</b> Клиент и сервер отделены друг от друга. Клиент отправляет запросы, сервер отвечает на них, а состояние клиентской сессии не сохраняется на сервере.</span><br>
    <span><b>Отсутствие состояния (Stateless):</b> Сервер не сохраняет состояние клиента между запросами. Каждое обращение от клиента содержит всю информацию, необходимую для выполнения запроса.</span><br>
    <span><b>Кеширование:</b> Ответы сервера можно кешировать, чтобы уменьшить нагрузку на сервер и улучшить производительность. Кешируемые данные обозначаются с помощью HTTP-заголовков, таких как Cache-Control.</span><br>
    <span><b>Единообразие интерфейса (Uniform Interface):</b> REST API имеют стандартизированный интерфейс. Это достигается за счет использования одинаковых HTTP-методов для выполнения операций.</span><br>
    <span><b>Разделение клиента и сервера (Layered System):</b> Система REST может состоять из нескольких слоев. Например, между клиентом и сервером могут находиться прокси-сервера, балансировщики нагрузки и другие компоненты.</span><br>
    <span><b>Возможность кодирования на стороне клиента:</b> Сервер может посылать клиенту код, который будет выполнен на его стороне (например, JavaScript-код для веб-приложения).</span><br>
    <strong>Основные HTTP-методы в REST:</strong><br>
    <span>1. Метод <b>GET</b> используется для запроса данных с сервера. Он не изменяет состояние на сервере, поэтому считается безопасным.</span>
    <span>2. Метод <b>POST</b> используется для создания нового ресурса на сервере. Обычно сопровождается телом запроса, содержащим данные для создания.</span>
    <span>3. Метод <b>PUT</b> заменяет существующий ресурс новыми данными. В отличие от PATCH, PUT требует отправки всех полей ресурса, даже если обновляются только некоторые.</span>
    <span>4. Метод <b>PATCH</b> позволяет обновить только часть данных ресурса. Это полезно, если нужно изменить только несколько полей, не влияя на остальные.</span>
    <span>5. Метод <b>DELETE</b> удаляет ресурс на сервере. Обычно не требует тела запроса.</span>
    <span>5. Метод <b>OPTIONS</b> возвращает информацию о разрешённых методах для конкретного ресурса. Это полезно для определения доступных методов и заголовков, которые поддерживает сервер. Этот метод часто используется для проверки поддержки CORS (Cross-Origin Resource Sharing).</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `fetch('https://example.com/api/users', {
method: 'GET',
headers: {
'Authorization': 'Bearer <token>'
}
})
.then(response => {
if (!response.ok) {
throw new Error("Ошибка");
}
return response.json();
})
.then(data => console.log(data))
.catch(error => console.error('Ошибка:', error));

fetch(‘https://example.com/api/users’, {
method: ‘POST’,
headers: {
‘Content-Type’: ‘application/json’,
‘Authorization’: ‘Bearer <token>’
},
body: JSON.stringify({
name: ‘Alice’,
email: ‘alice@example.com’,
password: ‘securepassword’
})
})
.then(response => response.json())`
  },
  {
    number: 6,
    title: `Как остановить запрос на сервер ?`,
    shortAnswer: '',
    longAnswer: `<strong>AbortController</strong><br><span> это встроенный объект в JavaScript, который используется для управления и отмены асинхронных операций, таких как сетевые запросы, выполняемые с помощью fetch. Он создает сигнал отмены (abort signal), который может быть связан с запросом и в любой момент вызван для прерывания этого запроса.</span><br>
    <strong>Как использовать AbortController</strong><br>
    <span>1. Создать экземпляр AbortController.</span>
    <span>2. Передать его сигнал (signal) в опции fetch.</span>
    <span>3. Вызвать метод .abort() у контроллера для прерывания запроса.</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `const controller = new AbortController();
const { signal } = controller;
async function fetchData() {
try {
const response = await fetch(‘https://jsonplaceholder.typicode.com/posts’, { signal });
if (!response.ok) {
throw new Error(‘Network response was not ok’);
}
const data = await response.json();
console.log(data);
} catch (error) {
if (error.name === ‘AbortError’) {
console.log(‘Запрос был прерван’);
} else {
console.error(‘Произошла ошибка:’, error);
}}}
fetchData();
setTimeout(() => {
controller.abort();
console.log(‘Запрос был прерван по истечении таймера’);
}, 3000);`
  },
  {
    number: 7,
    title: `Что такое WebSockets ?`,
    shortAnswer: '',
    longAnswer: `<strong>WebSocket</strong><span> это сетевой протокол, позволяющий устанавливать постоянное двустороннее соединение между клиентом (например, браузером) и сервером. Он обеспечивает быструю и эффективную передачу данных в реальном времени с минимальной задержкой, позволяя клиенту и серверу обмениваться сообщениями по одному соединению без необходимости повторных HTTP-запросов.</span><br>
    <strong>Преимущества WebSockets:</strong><br>
    <span><b>Двусторонняя связь:</b> Сервер может отправлять данные клиенту без запроса от клиента, что идеально для чатов, финансовых приложений и игр.</span>
    <span><b>Постоянное соединение:</b> Поддерживается одно открытое соединение, что снижает накладные расходы на повторные запросы и уменьшает задержки.</span>
    <span><b>Эффективность:</b> Меньший размер заголовков фреймов и отсутствие необходимости в повторных HTTP-запросах позволяет экономить трафик и повышать скорость передачи данных.</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `const socket = new WebSocket(‘ws://example.com/socket’);
socket.onopen = () => {
console.log(‘Соединение установлено.’);
// Отправка сообщения на сервер
socket.send(‘Привет, сервер!’);
};
socket.onmessage = (event) => {
console.log(‘Сообщение от сервера:’, event.data);
};
socket.onerror = (error) => {
console.log(‘Ошибка:’, error);
};
socket.onclose = () => {
console.log(‘Соединение закрыто.’);
};`
  },
  {
    number: 8,
    title: `Что такое Server-Sent Events (SSE) ?`,
    shortAnswer: '',
    longAnswer: `<strong>Server-Sent Events (SSE)</strong><span> это технология, позволяющая серверу отправлять обновления клиенту через HTTP-соединение. В отличие от WebSockets, SSE поддерживает только однонаправленное соединение: сервер может отправлять данные клиенту, но клиент не может отправлять данные обратно по тому же соединению.</span><br>
    <strong>Преимущества SSE:</strong><br>
    <span><b>Простота использования:</b> SSE работает поверх HTTP и легко поддерживается большинством браузеров.</span>
    <span><b>Автоматическое восстановление:</b> Клиенты автоматически повторяют попытку подключиться к серверу, если соединение разрывается.</span>
    <span><b>Меньше накладных расходов:</b> SSE не требует специальных протоколов, работает через стандартный HTTP и оптимизирован для отправки текстовых данных.</span><br>
    <strong>Ограничения SSE:</strong><br>
    <span><b>1. Однонаправленность:</b> SSE позволяет только серверу отправлять данные клиенту, но не наоборот. Для двустороннего общения требуется использовать другие технологии, такие как WebSocket.</span>
    <span><b>2. Отсутствие поддержки в некоторых браузерах:</b> Хотя большинство современных браузеров поддерживают SSE, он не работает в Internet Explorer.</span>
    <span><b>3. Работа через HTTP/1.x:</b> SSE не оптимизирован для HTTP/2, и хотя он будет работать, WebSockets или другие технологии могут быть более эффективными для сложных задач.</span>
    `,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 9,
    title: `Что такое short-polling / long-polling ?`,
    shortAnswer: '',
    longAnswer: `<strong>Short polling</strong><span> это метод, при котором клиент через определенные интервалы времени отправляет HTTP-запросы на сервер, чтобы проверить, есть ли новые данные.</span><br>
    <strong>Как работает short polling?</strong><br>
    <span>1. Клиент отправляет запрос на сервер.</span>
    <span>2. Сервер сразу отвечает данными (даже если обновлений нет).</span>
    <span>3. Клиент обрабатывает ответ и ждет некоторое время (например, 5 секунд)./strong>
    <span>4. Через заданный интервал снова отправляет запрос.</span><br>
    <strong>Плюсы short polling:</strong><br>
    <span>1. Простая реализация (обычные HTTP-запросы).</span>
    <span>2. Подходит для редких обновлений (например, обновление списка товаров).</span><br>
    <strong>Минусы short polling:</strong><br>
    <span>1. Высокая нагрузка на сервер (даже если данных нет, клиент все равно делает запросы).</span>
    <span>2. Задержка получения новых данных (зависит от частоты опроса).</span><br>
    <strong>Long polling</strong><span> это улучшенный вариант short polling. Вместо того чтобы сервер сразу отвечал клиенту, он удерживает соединение до появления новых данных.</span><br>
    <strong>Как работает long polling?</strong><br>
    <span>1. Клиент отправляет HTTP-запрос на сервер.</span>
    <span>2. Если новые данные есть → сервер сразу их отправляет клиенту.</span>
    <span>3. Если новых данных нет, сервер ждет (например, 30 секунд) и отправляет ответ, когда данные появятся./strong>
    <span>4. После получения данных клиент сразу отправляет следующий запрос, обеспечивая непрерывное обновление.</span><br>
    <strong>Плюсы long polling:</strong><br>
    <span>1. Меньшая нагрузка на сервер (запросы отправляются реже, только при наличии новых данных).</span>
    <span>2. Мгновенное получение обновлений.</span><br>
    <strong>Минусы long polling:</strong><br>
    <span>1. Сервер должен поддерживать длительные соединения.</span>
    <span>2. Может вызвать проблемы с масштабируемостью при большом числе подключений.</span><br>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 10,
    title: `Что такое Local Storage ?`,
    shortAnswer: '',
    longAnswer: `<strong>Local Storage</strong><span> предоставляет возможность хранения данных, которые будут доступны даже после закрытия браузера или перезагрузки страницы. Это означает, что данные сохраняются на неопределенный срок, пока они не будут явно удалены.</span><br>
    <strong>Объем хранения:</strong><span> обычно Local Storage позволяет хранить до 5-10 МБ данных на домен.</span>
    <strong>Время жизни данных:</strong><span> данные, сохраненные в Local Storage, сохраняются до тех пор, пока не будут удалены через JavaScript или пользователь не очистит данные браузера.</span><br>
    <strong>Доступ к данным:</strong><span> доступ к Local Storage осуществляется через объект localStorage, который предоставляет несколько основных методов:</span>
    <span><b>setItem(key, value)</b> — для добавления или обновления значения по ключу.</span>
    <span><b>getItem(key)</b> — для получения значения по ключу.</span>
    <span><b>removeItem(key)</b> — для удаления значения по ключу.</span>
    <span><b>clear()</b> — для удаления всех данных из Local Storage.</span>
    <span><b>key(index)</b> — для получения имени ключа по индексу.</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `localStorage.setItem(‘username’, ‘JohnDoe’);
// Получение данных
const username = localStorage.getItem(‘username’);
console.log(username); // JohnDoe
// Удаление данных
localStorage.removeItem(‘username’);
// Очистка всего Local Storage
localStorage.clear();`
  },
  {
    number: 11,
    title: `Что такое Session Storage ?`,
    shortAnswer: '',
    longAnswer: `<strong>Session Storage</strong><span> предоставляет временное хранение данных, которые будут доступны только в рамках текущей сессии браузера. Это означает, что данные сохраняются только до тех пор, пока вкладка или окно браузера остаются открытыми.</span><br>
    <strong>Объем хранения:</strong><span> Session Storage обычно позволяет хранить аналогичное количество данных, как и Local Storage (до 5-10 МБ на домен).</span>
    <strong>Время жизни данных:</strong><span> данные в Session Storage удаляются, когда вкладка или окно браузера закрываются.</span><br>
    <strong>Доступ к данным:</strong><span> Session Storage использует объект sessionStorage, который имеет те же методы, что и Local Storage:</span>
    <span><b>setItem(key, value)</b> — для добавления или обновления значения по ключу.</span>
    <span><b>getItem(key)</b> — для получения значения по ключу.</span>
    <span><b>removeItem(key)</b> — для удаления значения по ключу.</span>
    <span><b>clear()</b> — для удаления всех данных из Local Storage.</span>
    <span><b>key(index)</b> — для получения имени ключа по индексу.</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `// Сохранение данных
sessionStorage.setItem(‘sessionUser’, ‘JaneDoe’);
// Получение данных
const sessionUser = sessionStorage.getItem(‘sessionUser’);
console.log(sessionUser); // JaneDoe
// Удаление данных
sessionStorage.removeItem(‘sessionUser’);
// Очистка всего Session Storage
sessionStorage.clear();`
  },
  {
    number: 12,
    title: `Что такое cookies ?`,
    shortAnswer: '',
    longAnswer: `<span>Хранение данных с помощью cookies в JavaScript — это один из методов, который позволяет сохранять небольшие объемы информации на стороне клиента. Cookies представляют собой текстовые файлы, которые хранятся в браузере пользователя и отправляются на сервер при каждом запросе. Вот основные аспекты, которые стоит учитывать при работе с cookies:</span>
    <strong>Параметры cookie</strong>
    <span><b>expires:</b> указывает дату и время, когда cookie истечет. Если этот параметр не задан, cookie будет храниться до закрытия браузера</span>
    <span><b>path:</b> определяет путь, для которого cookie будет доступно. По умолчанию это текущий путь. Если указать /, cookie будет доступно для всех страниц сайта.</span>
    <span><b>domain:</b> указывает домен, к которому cookie относится. Если не указан, cookie будет доступно только для текущего домена.</span>
    <span><b>secure:</b> если установлен, cookie будет передаваться только по защищенным (HTTPS) соединениям.</span>
    <span><b>SameSite:</b> контролирует, отправляются ли cookie с запросами из сторонних сайтов. Возможные значения:</span>
    <span><b>Lax</b> (по умолчанию) — cookie отправляются с запросами на сайте, но не с кросс-доменных.</span>
    <span><b>Strict</b> — cookie не отправляются с кросс-доменных запросов.</span>
    <span><b>LNone</b> — cookie отправляются с кросс-доменных запросов, но должны быть безопасными.</span><br>
    <span>Cookies удобны для хранения небольших объемов данных, таких как информация о сессиях и предпочтениях пользователя. Однако для более сложных приложений и больших объемов данных могут быть предпочтительнее другие методы, такие как локальное хранилище (localStorage) или сессии (sessionStorage).</span>`,
    frequency: 4,
    language: "javascript",
    codeExample: `// Создание cookie с именем “username” и значением “JohnDoe”
document.cookie = “username=JohnDoe; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/”;`
  },
  {
    number: 13,
    title: `Безопасное хранение cookies ?`,
    shortAnswer: '',
    longAnswer: `<span>Безопасное хранение <b>cookies</b> является важным аспектом веб-разработки, чтобы защитить данные пользователей и предотвратить различные атаки, такие как XSS (межсайтовый скриптинг) и CSRF (межсайтовая подделка запросов). Вот несколько методов, которые помогут обеспечить безопасность cookies:</span><br>
    <span>1. Использование флага <b>HttpOnly</b></span>
    <span>Установка флага HttpOnly для cookie предотвращает доступ к нему через JavaScript, что защищает данные от атак XSS. Cookie с этим флагом могут быть отправлены только на сервер.</span><br>
    <span>2. Использование флага <b>Secure</b></span>
    <span>Флаг Secure гарантирует, что cookie будет передаваться только по защищенным (HTTPS) соединениям. Это защищает данные от перехвата при передаче по незащищенным соединениям.</span><br>
    <span>3. Установка <b>SameSite</b> атрибута</span>
    <span>Атрибут SameSite помогает предотвратить атаки CSRF, ограничивая отправку cookie с кросс-доменных запросов. Использование значений Strict или Lax позволяет повысить безопасность.</span><br>
    <span>4. Минимизация объема данных в cookies</span>
    <span>Старайтесь хранить только необходимую информацию в cookies. Избегайте хранения конфиденциальных данных (например, паролей) и больших объемов информации, чтобы уменьшить риски.</span><br>
    <span>5. Регулярная ротация и истечение сроков действия</span>
    <span>Регулярно обновляйте и ротацию cookies, чтобы снизить риск их перехвата. Установите срок действия для cookies, чтобы они автоматически удалялись через определенное время.</span><br>`,
    frequency: 4,
    language: "javascript",
  },
]

export const ARCHITECTURE = [
  {
  number: 1,
  title: `Что такое чистая функция ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Чистая функция</strong>
  <span>это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов. Чистые функции являются ключевой концепцией
  в функциональном программировании, так как они делают код более предсказуемым и легко тестируемым.</span><br>
  <strong>Свойства чистых функций</strong><br>
  <span><b>1. Детерминированность:</b> Чистая функция всегда возвращает один и тот же результат, если ей переданы одинаковые аргументы. Например, функция, которая только складывает два числа, будет всегда возвращать одно и то же значение для одних и тех же чисел.</span><br>
  <span><b>2. Отсутствие побочных эффектов:</b> Чистая функция не изменяет внешние состояния, такие как глобальные переменные, значения аргументов или состояния объектов. Она работает только с данными, переданными ей, и не влияет на что-либо за её пределами.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function doubleArray(arr) {
  return arr.map(num => num * 2);
}

const numbers = [1, 2, 3];
console.log(doubleArray(numbers)); // [2, 4, 6]
console.log(numbers); // [1, 2, 3] (исходный массив не изменился)
 `
},
{
  number: 2,
  title: `Графы, создайте граф и напишите основные методы`,
  shortAnswer: '',
  longAnswer: `
  <strong>Графы в JavaScript</strong>
  <span>это структура данных, представляющая множество объектов и взаимосвязи между ними. Они могут использоваться для решения различных задач в программировании и алгоритмах, таких как поиск путей, анализ сетей, и другие.</span><br>
  <strong>Для чего нужны графы в JavaScript:</strong><br>
  <span><b>Моделирование сложных структур:</b> графы позволяют моделировать сложные отношения, например, в социальных сетях (друзья,подписчики), маршрутах (города, дороги), или сетях (узлы и соединения).</span><br>
  <span><b>Поиск путей и маршрутов:</b> алгоритмы, такие как алгоритм Дейкстры или A*, могут использоваться для поиска кратчайших путей в графах. Это может быть полезно в приложениях для навигации, таких как карты или GPS.</span><br>
  <span><b>Анализ данных:</b> графы могут использоваться для анализа данных, например, в системах рекомендателей (анализ связей между продуктами) или в кластеризации данных.</span><br>
  <span><b>Оптимизация:</b> графы могут помочь оптимизировать различные процессы, такие как управление потоками товаров в логистике или маршрутизация запросов в веб-приложениях.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `class Graph {
  constructor() {
    this.adjacencyList = new Map();
  }

  // Добавить вершину
  addVertex(vertex) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }

  // Добавить ребро (граф неориентированный)
  addEdge(vertex1, vertex2) {
    if (this.adjacencyList.has(vertex1) && this.adjacencyList.has(vertex2)) {
      this.adjacencyList.get(vertex1).push(vertex2);
      this.adjacencyList.get(vertex2).push(vertex1);
    }
  }

  // Удалить ребро
  removeEdge(vertex1, vertex2) {
    if (this.adjacencyList.has(vertex1) && this.adjacencyList.has(vertex2)) {
      this.adjacencyList.set(
        vertex1,
        this.adjacencyList.get(vertex1).filter(v => v !== vertex2)
      );
      this.adjacencyList.set(
        vertex2,
        this.adjacencyList.get(vertex2).filter(v => v !== vertex1)
      );
    }
  }

  // Удалить вершину
  removeVertex(vertex) {
    if (this.adjacencyList.has(vertex)) {
      for (let neighbor of this.adjacencyList.get(vertex)) {
        this.removeEdge(vertex, neighbor);
      }
      this.adjacencyList.delete(vertex);
    }
  }

  // Обход в ширину (BFS)
  bfs(start) {
    const visited = new Set();
    const queue = [start];
    const result = [];

    while (queue.length) {
      const vertex = queue.shift();
      if (!visited.has(vertex)) {
        visited.add(vertex);
        result.push(vertex);
        queue.push(...this.adjacencyList.get(vertex).filter(v => !visited.has(v)));
      }
    }

    return result;
  }

  // Обход в глубину (DFS) - рекурсивный
  dfsRecursive(start, visited = new Set(), result = []) {
    if (!visited.has(start)) {
      visited.add(start);
      result.push(start);
      this.adjacencyList.get(start).forEach(neighbor => this.dfsRecursive(neighbor, visited, result));
    }
    return result;
  }
}

// Пример использования:
const graph = new Graph();
graph.addVertex("A");
graph.addVertex("B");
graph.addVertex("C");
graph.addVertex("D");

graph.addEdge("A", "B");
graph.addEdge("A", "C");
graph.addEdge("B", "D");
graph.addEdge("C", "D");

console.log("Обход в ширину (BFS):", graph.bfs("A"));
console.log("Обход в глубину (DFS):", graph.dfsRecursive("A"));`
},
{
  number: 3,
  title: `Структуры данных (Стек, Очередь, Связанные списки, Деревья, Графы)`,
  shortAnswer: '',
  longAnswer: `
  <span><b>1. Стек</b> это структура данных, работающая по принципу “последний пришёл — первый вышел” (LIFO). Элементы добавляются и удаляются только с одного конца стека.</span><br>
  <strong>Методы:</strong>
  <span><b>push(item)</b> добавляет элемент на вершину стека.</span>
  <span><b>pop()</b> удаляет элемент с вершины стека.</span>
  <span><b>peek()</b> возвращает элемент на вершине стека без удаления.</span>
  <span><b>isEmpty()</b> проверяет, пуст ли стек.</span><br>
  <span><b>2. Очередь</b> это структура данных, работающая по принципу “первый пришёл — первый вышел” (FIFO). Элементы добавляются в конец очереди и удаляются из начала.</span><br>
  <strong>Методы:</strong>
  <span><b>enqueue(item)</b> добавляет элемент в конец очереди.</span>
  <span><b>dequeue()</b> удаляет элемент из начала очереди.</span>
  <span><b>front()</b> возвращает элемент в начале очереди без удаления.</span>
  <span><b>isEmpty()</b> проверяет, пуста ли очередь.</span><br>
  <span><b>3. Связанный список</b> это коллекция элементов, называемых узлами, где каждый узел содержит данные и ссылку на следующий узел. Существует несколько типов связанных списков: односвязный, двусвязный и кольцевой.</span><br>
  <strong>Методы:</strong>
  <span><b>add(value)</b> добавляет новый узел.</span>
  <span><b>remove(value)</b> удаляет узел.</span>
  <span><b>find(value)</b> ищет узел по значению.</span><br>
  <span><b>4. Деревья</b> это иерархическая структура данных, состоящая из узлов. Каждый узел имеет корень и дочерние узлы. Основные виды деревьев: бинарное дерево, бинарное дерево поиска (BST), AVL-дерево и B-дерево.</span><br>
  <strong>Методы:</strong>
  <span><b>insert(value)</b> добавляет элемент.</span>
  <span><b>search(value)</b> ищет элемент.</span>
  <span><b>traverse()</b> обход дерева (в ширину или в глубину).</span><br>
  <span><b>5. Граф</b> это набор узлов (вершин) и рёбер, соединяющих пары узлов. Графы могут быть ориентированными или неориентированными и могут содержать циклы.</span><br>
  <strong>Методы:</strong>
  <span><b>addVertex(vertex)</b> добавляет вершину.</span>
  <span><b>addEdge(vertex1, vertex2)</b> добавляет ребро между двумя вершинами.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 4,
  title: `Принцип SOLID`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Принципы SOLID</b> — это набор пяти принципов проектирования, которые помогают разработчикам создавать гибкий, поддерживаемый и масштабируемый код. Эти принципы способствуют улучшению качества кода и упрощают его понимание и модификацию. Давайте рассмотрим каждый из них подробнее.</span><br>
  <strong>S</strong><span> <b>— Single Responsibility Principle (Принцип единственной ответственности)</b></span>
  <span>Каждый класс должен иметь одну единственную ответственность, то есть одну причину для изменения.</span><br>
  <strong>O</strong><span> <b>— Open/Closed Principle (Принцип открытости/закрытости)</b></span>
  <span>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.</span><br>
  <strong>L</strong><span> <b>— Liskov Substitution Principle (Принцип подстановки Лисков)</b></span>
  <span>Объекты подтипов должны быть взаимозаменяемы с объектами базового типа, не нарушая корректность программы.</span><br>
  <strong>I</strong><span> <b>— Interface Segregation Principle (Принцип разделения интерфейса)</b></span>
  <span>Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше иметь несколько специализированных интерфейсов, чем один общий.</span><br>
  <strong>D</strong><span> <b>— Dependency Inversion Principle (Принцип инверсии зависимостей)</b></span>
  <span>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций (интерфейсов). Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций.</span><br>
  `,
  frequency: 4,
  language: "javascript",
},
{
  number: 5,
  title: `Принцип DRY, KISS`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Принцип DRY (Don’t Repeat Yourself)</b> — это важный принцип проектирования программного обеспечения, который гласит, что “не следует дублировать код”. Основная идея заключается в том, что каждое знание или логика должны быть представлены в системе единственным способом. Применение этого принципа помогает уменьшить количество дублирующегося кода, что делает приложение более чистым, поддерживаемым и удобным для изменения.</span><br>
  <span><b>Принцип KISS (Keep It Simple, Stupid)</b> — это один из основных принципов разработки программного обеспечения, который подчеркивает важность простоты в проектировании и реализации решений. Основная идея заключается в том, что системы и решения должны быть максимально простыми, чтобы облегчить их понимание, использование и поддержку.</span><br>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 6,
  title: `Основные принципы ООП`,
  shortAnswer: '',
  longAnswer: `<strong>1. Инкапсуляция</strong>
  <span> — это принцип, позволяющий скрывать внутреннее состояние объекта и предоставлять доступ к нему только через методы. Это способствует контролю доступа к данным и предотвращению их случайного изменения.</span><br>
  <strong>2. Наследование</strong>
  <span>— это принцип, при котором один класс может наследовать свойства и методы другого класса, что способствует повторному использованию кода и упрощению его поддержки. В JavaScript наследование реализуется с помощью ключевого слова extends, которое позволяет одному классу наследоваться от другого.</span><br>
  <strong>3. Полиморфизм</strong>
  <span> позволяет объектам использовать методы с одинаковыми именами, но с разной реализацией в зависимости от типа или класса объекта. В JavaScript полиморфизм достигается через переопределение методов в дочерних классах.</span><br>
  <strong>4. Абстракция</strong>
  <span>— это принцип, позволяющий выделить только значимые характеристики объекта и скрыть несущественные детали. В JavaScript абстракция часто реализуется через создание интерфейсов или абстрактных классов (хотя JavaScript не поддерживает абстрактные классы напрямую).</span><br>
  `,
  frequency: 4,
  language: "javascript",
},
{
  number: 7,
  title: `Паттерны проектирования в JavaScript`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Фабрика (Factory)</b> Паттерн Фабрика используется для создания объектов без необходимости указывать точный класс создаваемого объекта. Это позволяет делегировать создание объектов специальному методу или классу.</span><br>
  <span><b>Синглтон (Singleton)</b> Паттерн Синглтон гарантирует, что у класса будет только один экземпляр, ипредоставляет глобальную точку доступа к этому экземпляру. Это полезно, когда нужен контроль за ресурсами, например, для настройки подключения к базе данных или управления состоянием.</span><br>
  <span><b>Наблюдатель (Observer)</b> Паттерн Наблюдатель позволяет объекту оповещать другие объекты об изменениях, не зависимо от того, сколько их. Это очень полезно для создания событийных систем и реактивных приложений.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `class Subject {
constructor() {
this.observers = [];
}
addObserver(observer) {
this.observers.push(observer);
}
removeObserver(observer) {
this.observers = this.observers.filter(o => o !== observer);
}
notifyObservers(data) {
this.observers.forEach(observer => observer.update(data));
}
}
class Observer {
constructor(name) {
this.name = name;
}
update(data) {
console.log("{this.name} received data: {data}");
}
}
const subject = new Subject();
const observer1 = new Observer("Observer 1");
const observer2 = new Observer("Observer 2");`
},
{
  number: 8,
  title: `Модульная архитектура`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Модульная архитектура</b> — это подход к организации кода, при котором приложение разбивается на независимые, самодостаточные модули. Каждый модуль отвечает за конкретную часть функциональности, например, управление пользователями, обработку заказов, управление товарами и т.д. Эта архитектура особенно полезна для масштабируемых и легко поддерживаемых приложений, поскольку она позволяет выделить логику и компоненты, относящиеся к одной функциональной области.</span><br>
  <span><b>Основные принципы модульной архитектуры</b><span><br>
  <span><b>Изоляция:</b> Каждый модуль должен быть максимально независим от других. Это позволяет вносить изменения в один модуль, не затрагивая остальные.<span>
  <span><b>Повторное использование:</b> Модули разрабатываются таким образом, чтобы их можно было использовать в других проектах или в разных частях одного приложения.<span>
  <span><b>Единая ответственность:</b> Каждый модуль отвечает за определённую задачу. Это делает код более читабельным и упрощает тестирование.
  <b>Явные интерфейсы:</b> Коммуникация между модулями осуществляется через чётко определённые интерфейсы или API, что улучшает контроль над взаимодействием между модулями.<span><br>
  <span><b>Преимущества модульной архитектуры</b><span><br>
  <span><b>Простота тестирования и отладки:</b> Каждый модуль можно тестировать изолированно, что упрощает обнаружение и исправление ошибок.<span><br>
  <span><b>Лёгкость в поддержке:</b> Изменения в одном модуле, как правило, не требуют изменений в других.<span><br>
  <span><b>Масштабируемость:</b> Приложение проще расширять, добавляя новые модули с минимальными изменениями в уже существующих.<span><br>
  <span><b>Упрощённое разделение задач:</b> В командной разработке модули могут разрабатываться параллельно разными командами.<span><br>
  <strong>Структура модульного приложения</strong>
  <span>В модульной архитектуре проект обычно разбивается на папки по модулям, и каждый модуль имеет собственную внутреннюю структуру. Пример структуры модульного проекта<span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `src/
|--- auth/ //Модуль авторизации
| |--- components/ // UI-компоненты, относящиеся к авторизации
| |--- hooks/ // Хуки, относящиеся к авторизации
| |--- services/ // API-запросы или функции для взаимодействия с данными авторизации
| |--- store/ // Состояние и логику, например, Redux или Context для авторизации
|--- products/ // Модуль для работы с товарами
| |--- components/ // UI-компоненты для отображения товаров
| |--- hooks/ // Специфичные хуки для продуктов
| |--- services/ // API-запросы для работы с товарами
| |--- store/ // Состояние и бизнес-логика для продуктов
|--- orders/ // Модуль для заказов
| |--- components/
| |--- hooks/
| |--- services/
| |--- store/
|---shared/ // Общие компоненты, утилиты, и другие вспомогательные модули
|--- ui/ // Переиспользуемые UI-компоненты
|--- lib/ // Утилиты и хелперы, общие функции
|---config/ // Глобальные конфигурации`
    },
    {
      number: 9,
      title: `Архитектура FSD`,
      shortAnswer: '',
      longAnswer: `
      <span><b>Архитектура FSD (Feature-Sliced Design)</b> — это подход к структурированию фронтенд-приложений, который фокусируется на разделении кода по функциональным возможностям (features) и слоям. Это относительно новый метод организации кода, популярный в сообществе React-разработчиков и часто используемый для улучшения поддержки, масштабируемости и читабельности приложений.</span><br>
      <span><b>Основные принципы FSD</b><span><br>
      <span><b>Организация по функциональности:</b> Вместо организации проекта по типам файлов (например, компоненты, хуки, стили), все элементы, относящиеся к одной функциональной области, хранятся вместе. Например, все, что касается работы с пользователями, находится в одном месте.<span><br>
      <span><b>Разделение по слоям:</b> Внутри каждого функционального блока есть разделение на слои, такие как app, pages, features, entities, shared. Это помогает контролировать доступность кода между различными уровнями приложения и лучше управлять зависимостями.<span><br>
      <span><b>Контроль зависимостей:</b> Более высокоуровневые модули (например, features) могут зависеть от низкоуровневых (например, shared), но не наоборот. Это позволяет избежать «зависимостей сверху вниз».<span><br>
      <strong>Структура FSD</strong>
      <span>Архитектура FSD обычно состоит из следующих уровней (слоев):<span><br>
      <span><b>App:</b> Корневой слой приложения, который включает глобальные настройки, конфигурации, маршрутизацию и главное оформление.<span><br>
      <span><b>Pages:</b> Отображения страниц, которые представляют собой объединения нескольких функциональных блоков (features) и сущностей (entities).<span><br>
      <span><b>Features:</b> Функциональные блоки приложения, реализующие отдельные функции, например, «вход в систему» или «корзина покупок».<span><br>
      <span><b>Entities:</b> Сущности домена, такие как «Пользователь», «Продукт» или «Заказ». Это наиболее низкоуровневые объекты приложения.<span><br>
      <span><b>Shared:</b> Общие компоненты, утилиты, стили и функции, которые могут использоваться на любом уровне приложения.<span><br>
      <strong>Подробное описание каждого слоя</strong><br>
      <span><b>1. App</b> Это корневой уровень приложения. Здесь обычно хранятся: Глобальная настройка приложения (например, провайдеры состояния, темы). Основная конфигурация (например, конфигурация маршрутизации). Глобальные стили и тема приложения.<span><br>
      <span><b>2. Pages</b> Каждая страница приложения организуется как отдельная функциональная единица и объединяет несколько features и entities. Страницы также могут управлять собственными состояниями и логикой.<span><br>
      <span><b>3. Features</b> Этот слой отвечает за отдельные функциональные возможности (фичи) приложения. Каждая фича может включать в себя компоненты, логику (например, хуки), состояния (Redux или Context), а также стили.<span><br>
      <span><b>4. Entities</b> Слой entities представляет объекты, которые описывают сущности в системе, такие как «Пользователь», «Продукт» или «Заказ». Эти объекты не зависят от конкретных функциональных возможностей приложения, а являются базовыми структурами данных и их логикой.<span><br>
      <span><b>5. Shared</b> Слой shared предназначен для компонентов и утилит, которые используются на любом уровне приложения. Это могут быть базовые UI-компоненты, константы, утилиты, хуки и т. д.<span><br>
      <strong>Преимущества архитектуры FSD</strong>
      <span>Лёгкость в сопровождении: Структура FSD обеспечивает изоляцию логики, что упрощает её поддержку. Простота в навигации: Упрощается поиск нужного кода, так как каждая фича, страница и сущность находятся в соответствующих папках. Масштабируемость: Лёгкость добавления новых фич, страниц или сущностей, не нарушая общую архитектуру. Контроль зависимостей: Каждый слой имеет свои чёткие зависимости, что снижает вероятность возникновения циклических зависимостей. Улучшенная читаемость: Код лучше структурирован, что упрощает понимание приложения для новых разработчиков.<span><br>`,
      frequency: 4,
      language: "javascript",
    },
]

export const TYPESCRIPT_QUESTIONS = [
  {
    number: 1,
    title: `Что такое TypeScript и в чем его основные преимущества перед JavaScript?`,
    shortAnswer: '',
    longAnswer: `<strong>TypeScript</strong><span>— это строго типизированное надмножество JavaScript, разработанное Microsoft. TypeScript добавляет к JavaScript статическую типизацию и некоторые возможности, которые упрощают разработку сложных приложений и улучшают читаемость и поддержку кода. TypeScript компилируется в JavaScript, поэтому его можно использовать в любом проекте, где поддерживается JavaScript, включая браузеры и серверную среду.</span><br>
    <strong>Основные преимущества TypeScript перед JavaScript:</strong><br>
    <span>1. Статическая типизация</span><br>
    <span>2. Автодополнение и рефакторинг</span><br>
    <span>3. Интерфейсы и типы</span><br>
    <span>4. Поддержка новых возможностей JavaScript</span><br>
    <span>5. Инструменты для работы с крупными проектами</span><br> 
    <span>6. Поддержка ООП (объектно-ориентированного программирования)</span><br>
    <span>7. Интеграция с популярными библиотеками и фреймворками</span>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 2,
    title: `Какие основные типы данных существуют в TypeScript?`,
    shortAnswer: '',
    longAnswer: `<span><b>TypeScript</b> поддерживает основные типы данных, аналогичные JavaScript, а также добавляет дополнительные типы и механизмы, позволяющие лучше управлять структурой данных и снижать вероятность ошибок. Вот основные типы данных в TypeScript:</span><br>
    <span>1. <b>number</b> — Числовой тип. Поддерживает целые числа и числа с плавающей запятой.</span><br>
    <span>2. <b>string</b> — Строковый тип. Для строковых значений</span><br>
    <span>3. <b>boolean</b> — Логический тип. Может принимать значения true или false</span><br>
    <span>4. <b>array</b> — Массив. Определяется как type[] или Array<type></span><br>
    <span>5. <b>tuple</b> — Кортеж. Позволяет задать массив с фиксированным количеством элементов и разными типами</span><br> 
    <span>6. <b>enum</b> — Перечисление. Определяет набор именованных значений</span><br>
    <span>7. <b>any</b> — Произвольный тип. Отключает проверку типов. Используется, когда тип данных неизвестен на этапе написания кода</span><br>
    <span>8. <b>void</b> — Отсутствие значения. Обычно используется как возвращаемый тип функций, которые ничего не возвращают.</span><br> 
    <span>9. <b>null</b> и undefined — Специальные типы. Используются для значений null и undefined</span><br>
    <span>10. <b>never</b> — Тип, представляющий значения, которые никогда не возникают. Используется для функций, которые всегда выбрасывают ошибку или никогда не возвращают значение.</span><br>
    <span>11. <b>object</b> — Объектный тип. Представляет любой тип, который не является примитивным</span><br>
    <span>12. <b>unknown</b> — Тип для значений с неизвестным типом. Безопаснее, чем any, так как требует проверки типа перед использованием.</span><br>
    <span>13. <b>symbol</b> — Уникальный и неизменяемый тип, добавленный в ES6. Используется для создания уникальных идентификаторов.</span><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 3,
    title: `Какой синтаксис используется для объявления типов переменных в TypeScript?`,
    shortAnswer: '',
    longAnswer: `<span>В TypeScript синтаксис для объявления типов переменных состоит из указания типа переменной после двоеточия :. Пример базового синтаксиса:</span><br>`,
    frequency: 4,
    language: "typescript",
    codeExample: `let age: number = 25;
let name: string = “Alice”;
let isStudent: boolean = true;
let numbers: number[] = [1, 2, 3, 4];
let names: string[] = [“Alice”, “Bob”];
let person: { name: string; age: number } = { name: “Alice”, age: 25 };
interface Person {
name: string;
age: number;
}
let user: Person = { name: “Alice”, age: 25 };`
  },
  {
    number: 4,
    title: `Что такое interface, как и для чего он используется?`,
    shortAnswer: '',
    longAnswer: `<span><b>Interface</b> — это специальная конструкция для определения структуры объектов и классов, позволяющая задавать контракт на тип данных. Интерфейс описывает, какие свойства и методы должны присутствовать у объекта, а также их типы. Это делает код более понятным и позволяет TypeScript проверять типы на этапе компиляции.</span><br>
    <strong>Основные цели интерфейсов:</strong><br>
    <span><b>Определение структуры объектов</b> — интерфейсы позволяют задать обязательные свойства и их типы, которые объект должен содержать.</span>
    <span><b>Строгая типизация</b> — помогает TypeScript проверить, что объект соответствует ожидаемой структуре, что предотвращает ошибки на этапе разработки.</span>
    <span><b>Упрощение повторного использования</b> — интерфейсы создают стандартные описания объектов, которые можно применять в разных местах кода.</span>
    <span><b>Гибкость</b> — интерфейсы могут расширять друг друга, позволяя создавать сложные структуры данных.</span>
    `,
    frequency: 4,
    language: "typescript",
    codeExample: `interface User {
id: number;
name: string;
email?: string; // необязательное свойство
isActive: boolean;}`
  },
  {
    number: 5,
    title: `Какую роль выполняют Type , и чем они отличаются от interface?`,
    shortAnswer: '',
    longAnswer: `<strong>type</strong><span> — используется для объявления именованных типов, включая объекты, объединения, пересечения, кортежи, функции и примитивные значения. В отличие от interface, type не поддерживает расширение через extends, но может объединять несколько типов с помощью & и |.</span><br>`,
    frequency: 4,
    language: "typescript",
    codeExample: `type User = { id: number; name: string;}
    
  //Может быть объединён (union) или пересечён (intersection)

  type Admin = { role: "admin" };
  type User = { id: number; name: string };
  type AdminUser = Admin & User; // Пересечение типов

  //Может представлять примитивные значения, функции, массивы, кортежи

  type ID = string | number;
  type Point = [number, number];
  type GetUser = (id: number) => User;`
  },
  {
    number: 6,
    title: `Как работают Union и Intersection типы?`,
    shortAnswer: '',
    longAnswer: `<span><b>Union</b> типы позволяют переменной принимать значения нескольких разных типов. Они обозначаются вертикальной чертой | и означают, что переменная может быть либо одного, либо другого типа.</span>
    <span><b>Применение:</b> Используются, когда значение может быть нескольких типов и нужно предусмотреть работу с каждым из них.</span><br>
    <span><b>Intersection</b> типы позволяют создавать типы, которые объединяют свойства нескольких типов. Они обозначаются амперсандом & и означают, что переменная должна содержать свойства всех объединённых типов.</span>
    <span><b>Применение:</b> Используются, когда объект должен обладать характеристиками нескольких типов одновременно.</span>`,
    frequency: 4,
    language: "typescript",
    codeExample: `interface Person {
name: string;
age: number;
}
interface Employee {
companyId: string;
}
type PersonEmployee = Person & Employee;
const worker: PersonEmployee = {
name: “Alice”,
age: 30,
companyId: “XYZ-123”,
};`
  },
  {
    number: 7,
    title: `Что такое Generics, и как они помогают улучшить типизацию?`,
    shortAnswer: '',
    longAnswer: `<span><b>Generics в TypeScript</b> это способ создания универсальных компонентов, которые могут работать с различными типами данных, сохраняя строгую типизацию. Они позволяют писать обобщённые функции, классы и интерфейсы, которые автоматически подстраиваются под типы, с которыми они работают. Это помогает повысить гибкость кода и сделать его более безопасным, так как при использовании Generics TypeScript проверяет соответствие типов на каждом этапе работы.</span><br>
    <span><b>Как работают Generics:</b> Generics представляют собой параметры типов, которые обозначаются через символы, такие как <code>&lt;T&gt;</code>, <code>&lt;U&gt;</code>, <code>&lt;K, V&gt;</code> и другие. В функции, классе или интерфейсе можно использовать эти параметры для указания типов переменных, аргументов и возвращаемых значений.</span><br>
    <span><b>Преимущества Generics:</b> позволяют использовать одну и ту же функцию или класс для разных типов данных. Безопасность типов: сохраняют информацию о типе, поэтому TypeScript может проверять типы на этапе компиляции. Читабельность и переиспользуемость кода: создаются универсальные компоненты, которые легко адаптировать под разные типы данных.</span>`,
    frequency: 4,
    language: "typescript",
    codeExample: `// Пример 1: Дженерик-функция
  function identity<T>(value: T): T {
  return value;
}

  const numberValue = identity<number>(42);  // number
  const stringValue = identity<string>("Hello");  // string
  
  //Пример 2: Дженерик-интерфейс

  interface Box<T> {
  content: T;
}

  const numberBox: Box<number> = { content: 100 };
  const stringBox: Box<string> = { content: "TypeScript" };

  //Пример 3: Дженерик-класс

 class Storage<T> {
  private items: T[] = [];

  addItem(item: T) {
    this.items.push(item);
  }

  getItems(): T[] {
    return this.items;
  }
}

const numberStorage = new Storage<number>();
numberStorage.addItem(5);
numberStorage.addItem(10);
console.log(numberStorage.getItems()); // [5, 10]`
  },
  {
    number: 8,
    title: `Как работают Union и Intersection типы?`,
    shortAnswer: '',
    longAnswer: `<span><b>Union</b> типы позволяют переменной принимать значения нескольких разных типов. Они обозначаются вертикальной чертой | и означают, что переменная может быть либо одного, либо другого типа.</span>
    <span><b>Применение:</b> Используются, когда значение может быть нескольких типов и нужно предусмотреть работу с каждым из них.</span><br>
    <span><b>Intersection</b> типы позволяют создавать типы, которые объединяют свойства нескольких типов. Они обозначаются амперсандом & и означают, что переменная должна содержать свойства всех объединённых типов.</span>
    <span><b>Применение:</b> Используются, когда объект должен обладать характеристиками нескольких типов одновременно.</span>`,
    frequency: 4,
    language: "typescript",
    codeExample: `interface Person {
name: string;
age: number;
}
interface Employee {
companyId: string;
}
type PersonEmployee = Person & Employee;
const worker: PersonEmployee = {
name: “Alice”,
age: 30,
companyId: “XYZ-123”,
};`
  },
  {
    number: 9,
    title: `Основные Utility Types в TypeScript`,
    shortAnswer: '',
    longAnswer: `<span><b>Partial<code>&lt;T&gt;</b></code> – делает все свойства объекта необязательными.</span><br>
    <span><b>Required<code>&lt;T&gt;</b></code> – делает все свойства обязательными.</span><br>
    <span><b>Readonly<code>&lt;T&gt;</b></code> –  делает все свойства только для чтения.</span><br>
    <span><b>Pick<code>&lt;T, K&gt;</b></code> – выбирает только указанные свойства из типа.</span><br>
    <span><b>Omit<code>&lt;T, K&gt;</b></code> – исключает указанные свойства.</span><br>
    <span><b>Record<code>&lt;K, T&gt;</b></code> – создаёт объект с ключами типа K и значениями типа T.</span><br>
    <span><b>Exclude<code>&lt;T, U&gt;</b></code> – удаляет из T те типы, которые есть в U.</span><br>
    <span><b>Extract<code>&lt;T, U&gt;</b></code> – ыбирает только те типы, которые есть в U.</span><br>
    <span><b>NonNullable<code>&lt;T&gt;</b></code> – удаляет null и undefined.</span><br>
    <span><b>ReturnType<code>&lt;T&gt;</b></code> – извлекает тип возвращаемого значения из функции.</span>
    `,
    frequency: 4,
    language: "typescript",
  },



];