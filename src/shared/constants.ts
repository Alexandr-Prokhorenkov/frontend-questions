export const HTML_CSS_QUESTIONS = [
  {
    number: 1,
    title: `Что такое HTML и CSS? Для чего они используются?`,
    shortAnswer: '',
    longAnswer: `<strong>HTML —</strong> <span>это язык разметки, который используется для создания структуры веб-страницы.<br>
    Он определяет, какие элементы будут присутствовать на странице и как они структурированы.</span><br>
    
    <strong>CSS —</strong> <span>это язык таблиц стилей, который используется для оформления внешнего вида веб-страницы.<br>
    Он позволяет управлять стилем и расположением элементов на странице.</span><br><br>
    
    <strong>Как работают вместе:</strong><br>
    <span>HTML задает структуру, а CSS — стили и дизайн. Например, HTML создаст заголовок, а CSS задаст его цвет и выравнивание.<br>
    Пример совместного использования:</span>`,
    frequency: 4,
    language: "html",
    codeExample: `<!DOCTYPE html>
<html lang="ru">
<head>
  <title>Пример страницы</title>
  <style>
    h1 {
      color: blue;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Привет, мир!</h1>
</body>
</html>`
  },
  {
    number: 2,
    title: `Cемантика HTML, и зачем ее использовать?`,
    shortAnswer: '',
    longAnswer: `<strong>Семантический HTML —</strong> <span>это использование HTML-тегов, которые ясно и точно описывают смысл
    их содержимого. В отличие от несемантических тегов, таких как <code>&lt;div&gt;</code> и <code>&lt;span&gt;</code>, семантические
    теги, например, <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;nav&gt;</code>, имеют четкое назначение и облегчают
    понимание структуры веб-страницы.</span><br> <strong>Преимущества семантического HTML:</strong> <span><br><b>Улучшение доступности (Accessibility):</b><br>
    Семантические теги помогают скринридерам (программам для чтения с экрана) понимать структуру страницы, что особенно важно для пользователей с ограниченными возможностями. Например, <code>&lt;nav&gt;</code> обозначает навигационный блок, что позволяет скринридеру быстро перемещаться
    по странице.<br><b>SEO (поисковая оптимизация):</b>
    Поисковые системы, такие как Google, используют семантические теги для определения важности
    контента. Это помогает улучшить ранжирование сайта в поисковых системах.<br><b>Поддерживаемость и читаемость кода:</b>
    Семантический HTML делает код более понятным для других разработчиков. Например, <code>&lt;article&gt;</code> сразу
    подсказывает, что внутри находится самостоятельный блок контента.
    Улучшение пользовательского опыта:
    Семантические теги позволяют браузерам и другим устройствам, например, умным колонкам,
    интерпретировать и отображать контент наиболее подходящим образом.
    <br><b>Соответствие стандартам:</b>
    Использование семантических тегов способствует написанию валидного кода, который соответствует
    стандартам W3C.</span><br><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 3,
    title: `Основные семантические теги и их назначение ?`,
    shortAnswer: '',
    longAnswer: `<strong><code>&lt;header&gt;</code></strong><span> Используется для создания шапки страницы или раздела.</span><br>
     <strong>Пример содержания:</strong><span> логотип, навигация, заголовок.</span><br><br>
     <strong><code>&lt;footer&gt;</code></strong><span> Определяет нижний колонтитул страницы или секции.</span><br>
     <strong>Пример содержания:</strong><span> контактная информация, копирайт, ссылки на политику конфиденциальности.</span><br><br>
     <strong><code>&lt;main&gt;</code></strong><span> Содержит основной контент страницы, уникальный для данной страницы.</span><br>
     <strong>Пример содержания:</strong><span> содержит только уникальный контент страницы (основной контент).</span><br><br>
     <strong><code>&lt;section&gt;</code></strong><span> Используется для группировки связанных по смыслу элементов. Обычно имеет заголовок.</span><br><br>
     <strong><code>&lt;article&gt;</code></strong><span> Определяет самостоятельный блок контента, например, статью, новость или пост.</span><br><br>
     <strong><code>&lt;aside&gt;</code></strong><span> Определяет дополнительный контент, связанный с основным, например, боковую панель,
     рекламу, ссылки.</span><br><br>
     <strong><code>&lt;nav&gt;</code></strong><span> Определяет навигационное меню или группу ссылок.</span><br><br>
     <strong><code>&lt;figure&gt;</code> и <code>&lt;figcaption&gt;</code></strong><span> Используются для добавления иллюстраций с подписью..</span><br><br>
     <strong><code>&lt;time&gt;</code></strong><span> Указывает дату или время в стандартизированном формате.</span><br><br>
     <strong><code>&lt;mark&gt;</code></strong><span> Подсвечивает текст, имеющий важное значение.</span><br><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 4,
    title: `Какие типы полей ввода доступны через тег <input>?`,
    shortAnswer: '',
    longAnswer: `<strong><code>&lt;text&gt;</code></strong><span> Обычное текстовое поле для ввода текста.</span><br>
    <strong><code>&lt;password&gt;</code></strong> <span>Поле для ввода пароля. Текст скрыт с помощью символов (например, звездочек).</span><br>
    <strong><code>&lt;email&gt;</code></strong><span> Поле для ввода email-адреса. Браузер может проверять корректность ввода email.</span><br>
    <strong><code>&lt;number&gt;</code></strong><span> Поле для ввода чисел. Может иметь ограничения на минимальные и
    максимальные значения.</span><br>
    <strong><code>&lt;tel&gt;</code></strong> <span>Поле для ввода телефонного номера. Не проверяет формат ввода, но браузер может
    предложить клавиатуру, подходящую для ввода номера телефона.</span><br>
    <strong><code>&lt;url&gt;</code></strong> <span>Поле для ввода URL-адреса. Браузер может проверить правильность формата.</span><br>
    <strong><code>&lt;date&gt;</code></strong> <span>Поле для ввода даты. Браузер отображает календарь для выбора даты.</span><br>
    <strong><code>&lt;time&gt;</code></strong> <span>Поле для ввода времени (часы и минуты).</span><br>
    <strong><code>&lt;datetime-local&gt;</code></strong> <span>Поле для ввода даты и времени (без указания часового пояса).</span><br>
    <strong><code>&lt;month&gt;</code></strong> <span>Поле для ввода месяца и года.</span><br>
    <strong><code>&lt;week&gt;</code></strong> <span>Поле для ввода года и недели.</span><br>
    <strong><code>&lt;search&gt;</code></strong> <span>Поле для ввода поискового запроса. Это поле имеет семантическое значение для
    поиска.</span><br>
    <strong><code>&lt;file&gt;</code></strong> <span>Поле для выбора файла с устройства пользователя. Можно задать атрибуты для
    ограничения типов файлов.</span><br>
     <strong><code>&lt;checkbox&gt;</code></strong> <span>Поле для выбора одного или нескольких вариантов из предложенного списка</span><br>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 5,
    title: `Как связать <label> с <input>?`,
    shortAnswer: '',
    longAnswer: `<strong>Для связывания элемента <code>&lt;label&gt;</code> с элементом <code>&lt;input&gt;</code></strong>
    
    <span>в HTML используется атрибут for в теге
    <code>&lt;label&gt;</code> и атрибут id в теге <code>&lt;input&gt;</code>. Это связывание позволяет улучшить доступность формы и облегчить
    взаимодействие с пользователем.</span>`,
    frequency: 4,
    language: "html",
    codeExample: `<form action="/submit" method="POST">
    <label for="username">Username:</label>
    <input 
      type="text" 
      id="username" 
      name="username" 
      required 
      placeholder="Введите ваше имя"
    >
  
    <label for="email">Email:</label>
    <input 
      type="email" 
      id="email" 
      name="email" 
      required 
      placeholder="Введите ваш email"
    >
  
    <input type="submit" value="Отправить">
  </form>`
  },
  {
    number: 6,
    title: `Что такое каскад в CSS?`,
    shortAnswer: '',
    longAnswer: `<strong>Каскад (Cascade) в CSS —</strong><span>это принцип, по которому браузер решает, какие стили применить к элементам,
    когда существует несколько правил, применяемых к одному элементу. Каскад предполагает, что стили
    могут поступать из разных источников и могут перекрывать друг друга в зависимости от их специфичности,
    важности и порядка объявления.</span><br>
    <strong>Основные принципы каскада:</strong><br>
    <strong>Источник стилей:</strong><span> стили могут поступать из разных мест:
    Встроенные стили (внутри тега <code>&lt;style&gt;</code> в HTML или атрибут style на элементах)
    Внешние таблицы стилей (подключенные через тег <code>&lt;link&gt;</code>)
    Браузерные стили по умолчанию (если для элемента не указаны стили, браузер применяет свои дефолтные
    стили).</span><br><strong>Специфичность:</strong><span> это правило, которое определяет, какое правило имеет больший
    «приоритет». Чем более конкретным является селектор, тем выше его специфичность. Например:
    Селектор по тегу, такой как div, имеет низкую специфичность.
    Селектор по классу, такой как .class-name, имеет более высокую специфичность.
    Селектор по идентификатору, такой как #id-name, имеет еще более высокую специфичность.
    Inline-стили (например, style="..." на элементе) имеют наивысший приоритет.</span><br>
    <strong>Порядок объявления:</strong><span> если два правила имеют одинаковую специфичность, то браузер применит последнее
    объявленное правило. То есть, если одно правило приходит позже другого, оно будет иметь больший приоритет.</span><br>
    <strong>Важность (!important):</strong><span>Атрибут !important позволяет принудительно дать стиль более высокий приоритет,
    независимо от специфичности и порядка. Использование !important делает стиль наиболее важным, но его
    нужно применять осторожно, так как он нарушает нормальный порядок каскад</span>`,
    frequency: 4,
    language: "html",
  },
  {
    number: 7,
    title: `Псевдоклассы и псевдоэлементы?`,
    shortAnswer: '',
    longAnswer: `<strong>Псевдоклассы</strong><span> позволяют применять стили к элементам в определённом состоянии, например, когда они
    находятся в фокусе, на них наведена мышь, или они являются дочерними элементами какого-либо другого
    элемента.</span><br>
    <strong>:hover</strong><span> применяется к элементу, когда на него наводится курсор.</span><br>
    <strong>:focus</strong><span> применяется к элементу, когда он получает фокус, например, после клика или навигации с клавиатуры.</span><br>
    <strong>:active</strong><span> применяется к элементу в момент его активации, обычно при клике на элемент.</span><br>
    <strong>:visited</strong><span> применяется к ссылке, которую уже посещал пользователь.</span><br>
    <strong>:checked</strong><span> применяется к элементам формы (например, checkbox или radio), которые находятся в состоянии
    "отмечено" или "выбрано".</span><br>
    <strong>:disabled</strong><span> применяется к элементам формы, которые отключены (disabled).</span><br>
    <strong>:first-child</strong><span> применяется к первому дочернему элементу родителя.</span><br>
    <strong>:last-child</strong><span> применяется к последнему дочернему элементу родителя.</span><br>
    <strong>:nth-child()</strong><span> применяется к элементу, который является n-м дочерним элементом родителя. Можно
    использовать различные выражения для выбора элементов, например, :nth-child(2), :nth-child(odd)&nbsp;, :nth-child(3n)</span><br><br>
    <strong>Псевдоэлементы</strong><span> позволяют стилизовать несуществующие или скрытые части элементов, такие как текст до
    или после элемента, или первую букву/строку текста в блоке.</span><br>
    <strong>::before</strong><span> — вставляет контент перед содержимым элемента. Обычно используется для добавления иконок или
    текста перед содержимым.</span><br>
    <strong>::after</strong><span> — вставляет контент после содержимого элемента. Применяется для добавления декоративных
    элементов или текста после основного контента.`,
    frequency: 4,
    language: "html",
  },
  {
    number: 8,
    title: `Какие существуют виды позиционирования в CSS? Чем отличаются absolute, relative, fixed и sticky?`,
    shortAnswer: '',
    longAnswer: `<strong>Виды позиционирования:</strong><span><br><br>
    <strong>Static (статическое позиционирование)</strong><span> - элемент размещается в документе в порядке потока, сверху вниз.</span><br>
    <strong>Relative (относительное позиционирование)</strong><span> - элемент остаётся в потоке документа, но можно сдвинуть его
    относительно самого себя с помощью top, right, bottom, left.</span><br>
    <strong>Absolute (абсолютное позиционирование)</strong><span> - позиционируется относительно ближайшего предка с position: relative,
    absolute, или sticky.</span><br>
    <strong>Fixed (фиксированное позиционирование)</strong><span> - элемент фиксируется относительно окна браузера. Не сдвигается
    при прокрутке страницы. Всегда остаётся на одном месте.</span><br>
    <strong>Sticky (прилипшее позиционирование)</strong><span> - элемент комбинирует свойства relative и fixed:
    Работает как relative, пока не достигает указанного значения (top, left, и т. д.).
    Затем "прилипает" и ведёт себя как fixed относительно окна.</span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `.sticky-header {
    position: sticky;
    top: 0;
    background-color: orange;
    padding: 10px;
    font-size: 20px;
    font-weight: bold;
    text-align: center;
    border-bottom: 2px solid darkorange;
}`
  },
  {
    number: 9,
    title: `Как работает Flexbox и Grid?`,
    shortAnswer: '',
    longAnswer: `<strong>Flexbox (Flexible Box Layout) — </strong><span> - это технология в CSS, предназначенная для создания гибких и адаптивных
    макетов. Она позволяет удобно управлять расположением элементов внутри контейнера и их поведением
    при изменении размера контейнера. Flexbox позволяет выравнивать, распределять пространство между
    элементами и управлять их размерами в зависимости от доступного пространства.</span><br>
    <strong>Как работает Flexbox?</strong><span> Flexbox работает на основе контейнера, который становится flex-контейнером, и его дочерних элементов —
    flex-элементов. Все элементы внутри flex-контейнера могут быть расположены с использованием различных
    правил, таких как выравнивание, распределение пространства и изменение размеров.</span><br>
    <strong>Преимущества Flexbox:</strong><span><br>
    <span>Гибкость: Легко создавать адаптивные макеты.<br>
    Центрирование: Простое выравнивание элементов по горизонтали и вертикали.<br>
    Динамическое изменение: Элементы могут изменять свои размеры в зависимости от доступного пространства.</span><br>
    <strong>CSS Grid — </strong><span>это система макета в CSS, предназначенная для создания сложных двухмерных макетов (как по
    вертикали, так и по горизонтали). Она позволяет удобно и гибко управлять расположением элементов на
    странице, используя сетку с рядами и колонками. В отличие от Flexbox, который работает с элементами в одном
    направлении (либо по горизонтали, либо по вертикали), Grid позволяет работать с элементами как в строках,
    так и в колонках одновременно.</span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `.container {
    display: flex; 
    justify-content: space-between; /* Равномерно распределяем карточки */
    align-items: center; /* Выравнивание по центру */
    flex-wrap: wrap; /* Перенос элементов на новую строку, если не помещаются */
    gap: 20px; /* Расстояние между карточками */
    padding: 20px;
}
`
  },
  {
    number: 10,
    title: `Что такое медиа-запросы?`,
    shortAnswer: '',
    longAnswer: `<strong>Медиа-запросы (или media queries) — </strong><span> это важный инструмент в CSS, который позволяет применять
    различные стили в зависимости от характеристик устройства или окна браузера, таких как его ширина, высота,
    разрешение экрана, ориентация и другие параметры. Они играют ключевую роль в создании адаптивной
    верстки (responsive design), позволяя веб-страницам автоматически адаптироваться под различные экраны и
    устройства (от смартфонов до десктопов).</span><br>
    <strong>Применение медиа-запросов для адаптивной верстки</strong><br>
    <span>Адаптивная верстка позволяет страницам изменять свой дизайн в зависимости от размеров экрана устройства.
    С помощью медиа-запросов можно:
    Менять структуру и размеры элементов. Например, изменить количество колонок в сетке, уменьшить размеры
    текста на мобильных устройствах или скрыть ненужные элементы.
    Реализовывать мобильные версии. Например, на мобильных устройствах можно скрывать боковые панели
    или изменить навигацию для лучшего пользовательского опыта.
    Создавать мультимедийные страницы. Медиа-запросы позволяют адаптировать контент под разные виды
    устройств (например, планшеты и смартфоны).<span><br>`,
    frequency: 4,
    language: "css",
    codeExample: `@media (max-width: 768px) {
    .container {
        flex-direction: column; /* Карточки будут в колонку */
        align-items: center;
    }

    .card {
        max-width: 100%; /* Карточки займут всю ширину контейнера */
    }
}
`
  },
  {
    number: 11,
    title: `Чем отличается inline, block, и inline-block?`,
    shortAnswer: '',
    longAnswer: `<strong>Inline (Строчные элементы)</strong><br><br>
    <span>• Занимает только столько места, сколько необходимо содержимому.<br>
    • Нельзя задавать width и height, они игнорируются.<br>
    • На одной строке может находиться несколько inline-элементов.<br>
    <strong>Пример:</strong> <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code><br><br>
    <strong>Block (Блочные элементы)</strong><br><br>
    <span>• Занимает всю ширину родительского контейнера.<br>
    • Начинается с новой строки.<br>
    • Можно задавать width, height, margin, padding.<br>
    <strong>Пример:</strong> <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;section&gt;</code><br><br>
    <strong>Inline-block (Комбинированный)</strong><br><br>
    <span>• Ведёт себя как inline (не переносится на новую строку).<br>
    • Позволяет задавать width, height, margin, padding (в отличие от inline).<br>
    • Используется для создания гибких элементов (например, кнопки, меню, карточки).<br>`,
    frequency: 4,
    language: "css",
  },
];

export const JAVASCRIPT_QUESTIONS = [
  {
    number: 1,
    title: `Что такое Javascript ?`,
    shortAnswer: '',
    longAnswer: `<strong>Javascript</strong> <span>это язык программирования используемый для создания интерактивных элементов на веб-
    станицах. Он позволяет добавлять динамическое поведение к сайтам, такие как анимации, обработка
    событий, валидация форм и много другое.</span><br>
    <strong>Интерпретируемый язык:</strong> <span>JavaScript выполняется браузером напрямую,без необходимости
    компиляции. Это делает его идеальным для быстрого создания
    и тестирования веб-приложений.</span><br>
    <strong>Многофункциональность:</strong>
    <span>JavaScript можно использовать как на стороне клиента (frontend), так и на
    стороне сервера (backend) с помощью таких сред, как Node.js.</span><br>
    <strong>Асинхронность:</strong>
    <span>JavaScript поддерживает асинхронное выполнение задач через колбэки, промисы и
    async/await, что позволяет обрабатывать запросы и другие задачи, не блокируя основное выполнение
    кода.</span><br>
    <strong>Широкая экосистема:</strong>
    <span>JavaScript обладает большим количеством библиотек
    и фреймворков (React, Angular, Vue), которые упрощают разработку сложных веб-приложений.</span><br>
    <strong>Совместимость:</strong>
    <span>JavaScript поддерживается всеми современными браузерами
    и активно развивается сообществом и стандартами ECMA (например, ES6).</span>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 2,
    title: `Что такое Var Let и Const ?`,
    shortAnswer: '',
    longAnswer: `<strong>Var, Let и Const</strong> <span>это три способа объявления переменных в JavaScript, и они имеют
    различные особенности и области видимости. Вот основные различия между ними:</span><br>
    <strong>Область видимости:</strong><br><span><b>Var:</b> Переменные, объявленные с помощью var, имеют функциональную область видимости (если
    объявлены внутри функции) или глобальную область видимости (если объявлены вне функции). Это
    означает, что они доступны в пределах всей функции или в глобальном контексте.
    <b>Let и Const:</b> Оба имеют блочную область видимости, что означает, что они доступны только
    внутри блока кода, в котором были объявлены (например, внутри фигурных скобок {})</span><br>
    <strong>Повторное объявление:</strong>
    <span><b>Var:</b> Позволяет повторно объявлять переменные. Если вы попытаетесь объявить переменную с тем
    же именем в одной области видимости, это не вызовет ошибки.
    <b>Let:</b> Не позволяет повторное объявление переменных в одной области видимости. Если вы попробуете
    это сделать, получите ошибку.
    <b>Const:</b> Также не позволяет повторное объявление, как и let. Кроме того, переменные, объявленные с
    помощью const, должны быть инициализированы при объявлении и не могут быть переназначены.</span><br>
    <strong>Инициализация:</strong>
    <span><b>Var:</b> Переменные можно объявить без инициализации, и они будут иметь значение undefined по умолчанию.
    <b>Let:</b> Переменные также можно объявить без инициализации и будут иметь значение undefined.
    <b>Const:</b> Обязательно требует инициализации при объявлении. Если вы попытаетесь объявить
    переменную с const без инициализации, получите ошибку.</span><br>`,
    frequency: 4,
    language: "javascript",
  },
  {
    number: 3,
    title: `Как предотвратить изменение объекта ?`,
    shortAnswer: '',
    longAnswer: `<strong>Метод Object.freeze()</strong> <span>предотвращает изменения в объекте, делая его неизменяемым.
    После применения этого метода нельзя добавлять, удалять или изменять свойства объекта.</span><br>
    <strong>С помощью Object.defineProperty()</strong><span>вы можете установить свойства объекта как неуязвимые для
    изменений. Установив свойство с writable: false, вы запретите его изменение.</span><br>
    <span><b>Дискрипторы</b> свойств в JavaScript определяют характеристики свойств объектов. Каждый дискриптор
    свойства может содержать определенные атрибуты, которые контролируют поведение свойств.</span><br>
    <strong>writable:</strong><span> логическое значение, указывающее, можно ли изменять значение свойства (только для data
    descriptor).</span><br>
    <strong>enumerable:</strong><span> логическое значение, указывающее, перечисляется ли свойство при переборе свойств
    объекта (например, с помощью for...in или Object.keys()).</span><br>
    <strong>configurable:</strong><span> логическое значение, указывающее, можно ли изменять атрибуты свойства и удалять
    его из объекта (если false, то свойство нельзя удалить и его атрибуты нельзя изменять).</span><br>`,
    frequency: 4,
    language: "javascript",
  },
{
  number: 4,
  title: `Как клонировать объект в JS ?`,
  shortAnswer: '',
  longAnswer: `<strong>Поверхностное клонирование (Shallow Copy)</strong><br>
  <span>Метод <b>Object.assign()</b> позволяет создать поверхностную копию объекта
  Оператор распространения <b>(...)</b> также позволяет создать поверхностную копию объекта.</span><br>
  <strong>Глубокое клонирование (Deep Copy)</strong><br>
  <span>1. Использование <b>JSON.parse() и JSON.stringify().</b><span><br>
  <span>2. Для более сложных случаев и для поддержки всех типов данных можно использовать библиотеки,
  такие как <b>Lodash</b>, которая предоставляет функцию <b>_.cloneDeep()</b> для глубокого клонирования
  объектов.<span><br>
  <span>3. Метод <b>structuredClone()</b> позволяет сделать глубокую копию объекта, включая вложенные объекты,
  массивы и многие типы данных (например, Date, Map, Set, ArrayBuffer, и даже циклические структуры).
  Он работает более корректно и эффективно по сравнению с JSON.parse(JSON.stringify()), так как structuredClone
  не имеет ограничений на типы данных и сохраняет циклические ссылки.<span><br>
  <span>4. Написать свою рекурсивную функцию.<span>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj; // Возвращаем примитивы как есть
  }

  if (Array.isArray(obj)) {
    return obj.map(deepClone); // Клонируем массив рекурсивно
  }

  const clonedObj = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clonedObj[key] = deepClone(obj[key]); // Рекурсивное копирование
    }
  }

  return clonedObj;
}
`
},
{
  number: 5,
  title: `Типы данных в Javascript ?`,
  shortAnswer: '',
  longAnswer: `<strong>Примитивные типы данных</strong><br>
  <strong>1. string</strong><span> – для работы с текстом</span><br>
  <strong>2. number</strong><span> – для целых и дробных чисел</span><br>
  <strong>3. boolean</strong><span> – логический тип, который может быть либо true, либо false</span><br>
  <strong>4. undefined</strong><span>undefined – обозначает неопределенное значение. Если переменная объявлена, но не
  инициализирована, она имеет значение undefined</span><br>
  <strong>5. null</strong><span> обозначает “ничто” или “пустое значение”. Это значение может быть явно присвоено переменной</span><br>
  <strong>6. bigint</strong><span> для работы с большими целыми числами, которые не вмещаются в тип number</span><br>
  <strong>7. symbol</strong><span> используется для создания уникальных идентификаторов. Символы гарантированно
  уникальны и часто применяются для создания скрытых или защищенных свойств объекта</span><br><br>
  <strong>Объектные типы данных</strong><br>
  <strong>1. Object</strong><span> базовый объект в JavaScript, представляющий собой коллекцию пар “ключ-значение”</span><br>
  <strong>2. Array</strong><span> структура данных для хранения упорядоченных коллекций значений. Это также
  объект, который имеет методы для работы с элементами массива</span><br>
  <strong>3. Function</strong><span> особый тип объекта, который можно вызвать. Функции используются для
  выполнения задач и операций</span><br>
  <strong>4. Date</strong><span> встроенный объект для работы с датами и временем</span><br>
  <strong>5. RegExp</strong><span> регулярные выражения для поиска и работы со строками.</span>

  `,
  frequency: 4,
  language: "javascript",
},
{
  number: 6,
  title: `Коллекция MAP`,
  shortAnswer: '',
  longAnswer: `<strong>Map в JavaScript</strong>
  <span>— это встроенная структура данных, представляющая коллекцию пар “ключ-значение”.
  Она схожа с объектами, но обладает рядом ключевых особенностей, которые делают её более гибкой и
  удобной для ряда задач.</span><br>
  <strong>Основные характеристики Map</strong><br>
  <strong>1. Гибкость в типах ключей:</strong><span> В отличие от объектов, где ключами могут быть только строки или
  символы, в Map ключами могут быть <b>любые значения:</b> объекты, числа, функции, строки и другие типы
  данных. Это делает Map удобной для хранения различных типов данных в качестве ключей.</span><br>
  <strong>2. Сохранение порядка:</strong><span> Порядок вставки пар “ключ-значение” в Map сохраняется. При итерации
  элементы будут возвращаться в порядке их добавления.</span><br>
  <strong>3. Размер:</strong><span> Map предоставляет свойство size, которое возвращает количество пар “ключ-значение” в
  коллекции.</span><br>
  <strong>4. Производительность:</strong><span> Операции добавления, удаления и поиска в Map обычно быстрее, чем в
  объектах, особенно при работе с большим количеством записей.</span><br>
  <strong>4. Производительность:</strong><span> Операции добавления, удаления и поиска в Map обычно быстрее, чем в
  объектах, особенно при работе с большим количеством записей.</span><br>
  <strong>Основные методы Map</strong><br>
  <strong>set(key, value)</strong><span> добавляет элемент в Map с указанным ключом и значением. Если ключ уже существует,
  его значение будет обновлено.</span><br>
  <strong>get(key)</strong><span> возвращает значение, связанное с ключом. Если ключ не найден, возвращает undefined.</span><br>
  <strong>has(key)</strong><span> проверяет наличие элемента с указанным ключом в Map. Возвращает true, если ключ
  существует, иначе false.</span><br>
  <strong>delete(key)</strong><span> удаляет элемент по ключу и возвращает true, если удаление успешно. Если ключ не найден,
  возвращает false.</span><br>
  <strong>clear()</strong><span> удаляет все элементы из Map.</span><br>
  <strong>size</strong><span> свойство, возвращающее количество элементов в Map.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Создание коллекции Map
  const users = new Map();

  // Добавление элементов в Map
  users.set(1, "Александр");
  users.set(2, "Юлия");
  users.set(3, "Дмитрий");

  console.log(users); // Map(3) { 1 => 'Александр', 2 => 'Юлия', 3 => 'Дмитрий' }

  // Получение значения по ключу
  console.log(users.get(2)); // "Юлия"

  // Проверка наличия ключа
  console.log(users.has(3)); // true
  console.log(users.has(4)); // false

  // Удаление элемента
  users.delete(1);
  console.log(users); // Map(2) { 2 => 'Юлия', 3 => 'Дмитрий' }

  // Получение размера коллекции
  console.log(users.size); // 2`
},
{
  number: 7,
  title: `Коллекция SET`,
  shortAnswer: '',
  longAnswer: `<strong>Set в JavaScript</strong>
  <span> это встроенная коллекция для хранения уникальных значений любого типа. В отличие от массивов, Set не допускает повторяющихся элементов, что делает её полезной в задачах, где важно исключить дубликаты. Рассмотрим подробно, как работает Set, её методы и возможности.</span><br>
  <strong>Основные характеристики Set</strong><br>
  <strong>1. Уникальность элементов:</strong><span> В Set не может быть дубликатов. Если добавить в Set значение, которое уже присутствует, оно не будет добавлено повторно.</span><br>
  <strong>2. Любые типы данных:</strong><span> Как и в Map, в Set можно хранить значения любого типа: строки, числа, объекты, массивы, функции и другие.</span><br>
  <strong>3. Порядок хранения:</strong><span> Порядок вставки элементов в Set сохраняется, что позволяет итерироваться по
  элементам в порядке их добавления.</span><br>
  <strong>4. Оптимизированная производительность:</strong><span> Set обеспечивает быструю проверку наличия элемента, добавление и удаление.</span><br>
  <strong>Основные методы Set</strong><br>
  <strong>add(value)</strong><span> добавляет значение в Set. Если значение уже существует, оно не будет добавлено повторно.</span><br>
  <strong>delete(value)</strong><span> удаляет значение из Set, возвращая true, если значение было удалено, и false, если его не было в коллекции.</span><br>
  <strong>has(value)</strong><span> проверяет, существует ли значение в Set. Возвращает true, если значение есть, иначе false.</span><br>
  <strong>clear()</strong><span> удаляет все значения из Set.</span><br>
  <strong>size</strong><span> свойство, возвращающее количество элементов в Set.</span><br>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `// Создание Set
    const uniqueNumbers = new Set();

    // Добавление элементов
    uniqueNumbers.add(1);
    uniqueNumbers.add(2);
    uniqueNumbers.add(3);
    uniqueNumbers.add(2); // Повторяющийся элемент не добавится

    console.log(uniqueNumbers); // Set(3) { 1, 2, 3 }

    // Проверка наличия элемента
    console.log(uniqueNumbers.has(2)); // true
    console.log(uniqueNumbers.has(5)); // false

    // Удаление элемента
    uniqueNumbers.delete(1);
    console.log(uniqueNumbers); // Set(2) { 2, 3 }

    // Получение размера Set
    console.log(uniqueNumbers.size); // 2

    // Перебор элементов с помощью forEach
    uniqueNumbers.forEach(value => {
      console.log(value);
    });`
},
{
  number: 8,
  title: `Коллекция WeakMap`,
  shortAnswer: '',
  longAnswer: `<strong>WeakMap</strong>
  <span> это специальный вид коллекции в JavaScript, которая хранит пары “ключ-значение”. Однако у неё есть несколько уникальных особенностей, которые отличают её от обычного Map. Основные отличия
  заключаются в том, что WeakMap использует только объекты в качестве ключей и позволяет сборщику мусора автоматически удалять записи, когда на них нет других ссылок.</span><br>
  <strong>Основные характеристики WeakMap</strong><br>
  <strong>1. Ключи могут быть только объектами:</strong><span> ключами могут быть только объекты (например, {}, массивы, функции и т. д.). Примитивные типы, такие как строки или числа, нельзя использовать в качестве ключей.</span><br>
  <strong>2. Слабая ссылка на ключи:</strong><span> это значит, что если на объект-ключ больше нет ссылок в других частях
  программы, он будет удалён сборщиком мусора, и соответствующая запись в WeakMap также будет удалена.</span><br>
  <strong>3. Автоматическая очистка:</strong><span> Записи в WeakMap удаляются автоматически, если на ключ больше нет
  ссылок. Это делает WeakMap полезным для случаев, когда нужно ассоциировать данные с объектами,
  которые могут быть удалены из памяти, например, для реализации кэшей.</span><br>
  <strong>4. Невозможность итерации:</strong><span> Когда объект-ключ становится недоступным (отсутствуют другие ссылки), он автоматически удаляется из WeakMap.</span><br>
  <strong>Методы WeakMap</strong><br>
  <strong>set(key, value)</strong><span> добавляет запись в WeakMap. Если запись с таким ключом уже существует, она будет
  обновлена. Ключом может быть только объект.</span><br>
  <strong>get(key)</strong><span> возвращает значение, связанное с ключом. Если ключ не найден, возвращает undefined.</span><br>
  <strong>has(key)</strong><span> проверяет, существует ли запись с указанным ключом. Возвращает true, если запись
  существует, и false, если нет.</span><br>
  <strong>delete(key)</strong><span> удаляет запись с указанным ключом. Возвращает true, если удаление было успешным, и
  false, если ключ не найден.</span><br>
  `,
  frequency: 4,
  language: "javascript",
  codeExample: `const weakMap = new WeakMap();

  let obj1 = { name: "Alice" };
  let obj2 = { name: "Bob" };

  // Добавляем объекты в WeakMap
  weakMap.set(obj1, "Data for Alice");
  weakMap.set(obj2, "Data for Bob");

  console.log(weakMap.get(obj1)); // "Data for Alice"

  obj1 = null; // Объект удаляется, так как больше нет ссылок

  // Спустя некоторое время obj1 будет удалён GC, и его запись исчезнет из WeakMap`
},
{
  number: 9,
  title: `Коллекция WeakSet`,
  shortAnswer: '',
  longAnswer: `<strong>WeakSet</strong>
  <span> это специальный вид коллекции в JavaScript, которая хранит множество объектов и обладает рядом особенностей, которые отличают её от обычного Set. Основные характеристики WeakSet — это
  использование только объектов в качестве значений, слабые ссылки на эти объекты, и автоматическая очистка, если объект больше нигде не используется.</span><br>
  <strong>Основные характеристики WeakSet</strong><br>
  <strong>1. Только объекты в качестве значений:</strong><span> в отличие от обычного Set, в WeakSet можно добавлять
  только объекты. Примитивные значения, такие как строки, числа, или булевы значения, не могут быть элементами WeakSet</span><br>
  <strong>2. Слабые ссылки на объекты:</strong><span> WeakSet хранит слабую ссылку на каждый объект, который добавлен в
  коллекцию. Это означает, что если на объект больше нет других ссылок, он может быть удалён из памяти сборщиком мусора. Таким образом, WeakSet не предотвращает удаление объектов, которые в него добавлены.</span><br>
  <strong>3. Автоматическая очистка:</strong><span> Когда объект удаляется сборщиком мусора (если на него больше нет
  других ссылок), он также автоматически удаляется из WeakSet. Это делает WeakSet полезным для
  отслеживания объектов без необходимости вручную удалять их, когда они больше не нужны.</span><br>
  <strong>4. Нет методов для получения всех элементов или размера:</strong><span> У WeakSet нет методов для итерации
  (forEach, keys, values, entries) и нет свойства size, поскольку в любой момент объекты могут быть
  удалены сборщиком мусора. Это обеспечивает гибкость и экономию памяти, но делает WeakSet менее
  удобным для случаев, когда нужен доступ ко всем элементам.</span><br>
  <strong>Методы WeakSet</strong><br>
  <strong>add(value)</strong><span> добавляет объект в WeakSet. Если объект уже существует в коллекции, WeakSet его не
  добавляет (как и в обычном Set).</span><br>
  <strong>has(value)</strong><span> проверяет, находится ли объект в WeakSet. Возвращает true, если объект существует в
  коллекции, и false, если нет.</span><br>
  <strong>delete(value)</strong><span> удаляет объект из WeakSet. Возвращает true, если объект был успешно удалён, и false,
  если объект не найден в коллекции.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `const weakSet = new WeakSet();

  let user1 = { name: "Alice" };
  let user2 = { name: "Bob" };

  // Добавляем объекты в WeakSet
  weakSet.add(user1);
  weakSet.add(user2);

  console.log(weakSet.has(user1)); // true

  // Удаляем ссылку на user1
  user1 = null;

  // Теперь объект user1 будет удалён из памяти, и WeakSet автоматически очистится
  console.log(weakSet.has(user1)); // false (объект больше не существует)
  `
},
{
  number: 10,
  title: `Function Declaration Function Expression?`,
  shortAnswer: '',
  longAnswer: `<strong>Function Declaration</strong>
  <span> это способ определения функции по ключевому слову Function за которым
  следует имя функции, она всплывает в начало своей области видимости. Это значит что использовать
  функцию можно до ее объявления.</span><br>
  <strong>Как это работает:</strong><br>
  <span>• Когда JavaScript компилирует код, все функции, созданные с помощью function на уровне декларации, поднимаются (hoisted) в начало своей области видимости. Это означает, что функция доступна для вызова до её фактического места в коде.</span><br>
  <span>• Hoisting — это механизм, при котором объявления функций и переменных "поднимаются" в начало области видимости перед выполнением кода.</span><br>
  <span>• Такие функции можно вызывать в любом месте скрипта, даже до строки, где они были определены.</span><br>
  <strong>Function Expression</strong>
  <span> это создание функции в контексте выражения, часто присваиваемого переменной. Это может быть как анонимная функция (без имени), так и именованная.</span><br>
  <strong>Как это работает:</strong><br>
  <span>• Function Expressions создаются как часть выражений и могут быть присвоены переменным, переданы как аргументы в другие функции или возвращены из других функций.</span><br>
  <span>• Такие функции не поднимаются (не проходят через механизм hoisting), а становятся доступными только после выполнения выражени</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Объявление функции
function greet() {
  console.log("Hello, World!");
}

// Вызов функции до её объявления
greet(); // Выведет: "Hello, World!"

// Функциональное выражение
const greet = function() {
  console.log("Hello, World!");
};

// Вызов функции после её объявления
greet(); // Выведет: "Hello, World!"
  `
},
{
  number: 11,
  title: `Различие между стрелочной и обычной Функцией ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>1. Cинтаксис</strong><br>
  <strong>2. Поднятие (hoisting)</strong><br>
  <span>Обычные функции, объявленные как <b>Function Declaration</b>, поднимаются, то есть они могут быть
  вызваны до своего объявления.</span><br>
  <span>Стрелочные функции всегда являются <b>Function Expression</b>, поэтому не поднимаются и их можно
  вызывать только после объявления.</span><br>
  <strong>3. Контекст this</strong><br>
  <span><b>Обычные функции</b> имеют собственный контекст this, который определяется в момент вызова
  функции. Значение this зависит от того, как и где была вызвана функция (например, как метод объекта,
  как функция-конструктор или просто как функция).</span><br>
  <span><b>Стрелочные функции</b> не имеют собственного this. Они наследуют this из внешней области, в которой
  были объявлены. Это делает их удобными в случаях, когда нужно использовать тот же контекст this
  внутри вложенных функций.</span><br>
  <strong>4. Использование в качестве конструктора</strong><br>
  <span><b>Обычные функции</b> могут быть вызваны с помощью оператора new, создавая новый экземпляр
  объекта. Функции-конструкторы позволяют задавать свойства для новых объектов через this.</span><br>
  <span><b>Стрелочные функции</b> не могут быть использованы как конструкторы.</span><br>
  <strong>5. Отсутствие объекта arguments у стрелочных функций</strong>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 12,
  title: `Методы сравнения в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Не строгое равенство ==</strong><br>
  <span>сравнивает значения с приведением типов. Это значит, что перед сравнением JavaScript может преобразовать типы, чтобы они совпали.</span><br>
  <strong>Строгое равенство ===</strong><br>
  <span>сравнивает значения без приведения типов. Типы должны совпадать, иначе результат будет false.</span><br>
  <strong>Object.is()</strong><br>
  <span>Метод Object.is() проверяет два значения на равенство, почти как ===, но с некоторыми отличиями.
  Например, Object.is() считает +0 и -0 разными значениями, а NaN равен самому себе.</span><br>
  <strong>Сравнение объектов и массивов</strong><br>
  <span>В JavaScript объекты и массивы сравниваются по ссылке, а не по значению. Поэтому два объекта будут равны, только если они ссылаются на один и тот же объект в памяти.</span><br>
  <strong>Number.isNaN(value)</strong><br>
  <span>Предназначен для проверки является ли значение именно NaN, и отличается от глобальной функции
  isNaN() тем что он работает более строго и надежно.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Пример использования == и ===
  console.log(5 == "5");   // true
  console.log(5 === "5");  // false

  console.log(0 == false); // true
  console.log(0 === false); // false
  console.log(Object.is(5, 5));      // true
  console.log(Object.is(5, "5"));    // false
  console.log(Object.is(NaN, NaN));  // true
  console.log(Object.is(+0, -0));   // false
`
},
{
  number: 13,
  title: `Что такое замыкание ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Замыкание в JavaScript</strong><br>
  <span>это механизм, который позволяет функции "запомнить" своё лексическое окружение (среду), в котором она была создана, даже после того, как выполнение этого окружения завершилось. То есть, замыкание позволяет функции доступ к переменным из внешней функции, в которой она 
  была определена, даже если эта внешняя функция уже завершила выполнение.</span><br>
  <span>Замыкания являются важной концепцией в JavaScript, так как они позволяют создавать функции с приватными данными и сохранять состояние между вызовами функций.</span><br>
  <strong>Зачем это нужно?</strong><br>
  <span>• Создания приватных переменных: Когда вы хотите, чтобы переменные были недоступны напрямую из внешнего кода, но доступны через функции.</span><br>
  <span>• Функции с состоянием: Замыкания могут хранить состояние между вызовами.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function createCounter() {
  let count = 0; // Приватная переменная

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();

counter.increment(); // 1
counter.increment(); // 2
counter.decrement(); // 1
console.log(counter.getCount()); // 1 (получаем приватное состояние)`
},
{
  number: 14,
  title: `Делегирование событий ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Делегирование событий в JavaScript</strong><br>
  <span>это подход, при котором событие не привязывается непосредственно к каждому элементу, а к общему родительскому элементу. Когда событие происходит на дочернем элементе, 
  оно "всплывает" вверх по дереву DOM, и родительский элемент может перехватить его и обработать. 
  Это особенно полезно, когда вам нужно обрабатывать события для множества элементов, а не привязывать обработчики для каждого из них.</span><br>
  <strong>Как работает делегирование событий</strong><br>
  <span>При использовании делегирования событий мы устанавливаем один обработчик на родительский
  элемент. Затем, когда событие происходит на одном из дочерних элементов, оно всплывает вверх по
  DOM (механизм, называемый всплытием событий), и обработчик на родителе перехватывает его. В этом
  обработчике можно проверить, на каком именно дочернем элементе произошло событие, и выполнить
  соответствующие действия</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `<div id="buttonContainer">
  <button class="action-button">Button 1</button>
  <button class="action-button">Button 2</button>
  <button class="action-button">Button 3</button>
  <button class="action-button">Button 4</button>
</div>

// Получаем родительский элемент (div)
const buttonContainer = document.getElementById('buttonContainer');

// Используем делегирование событий
buttonContainer.addEventListener('click', function(e) {
  // Используем .closest() для поиска кнопки, на которую кликнули
  const button = e.target.closest('.action-button');

  if (button) {
    // Меняем стиль кнопки при клике
    button.style.backgroundColor = 'yellow';
    button.style.fontWeight = 'bold';
  }
});
`
},
{
  number: 15,
  title: `Атрибуты async и defer ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Атрибут async</strong><br>
  <span>Атрибут async указывает браузеру загружать скрипт асинхронно. Когда браузер обнаруживает скрипт
  с этим атрибутом, он загружает его параллельно с остальной частью страницы. После загрузки скрипт сразу выполняется, даже если HTML еще не завершил загрузку.</span><br>
  <strong>Особенности async:</strong><br>
  <span>• Загрузка происходит параллельно с HTML.</span>
  <span>• Выполнение скрипта происходит сразу после завершения загрузки, что может прервать 
  парсинг HTML.</span>
  <span>• Порядок выполнения не гарантируется, если несколько скриптов имеют атрибут async.</span>
  <strongАтрибут defer</strong>
  <span>Атрибут defer также загружает скрипт параллельно с HTML, но откладывает его выполнение до полной
  загрузки и парсинга HTML-документа. Скрипты с defer выполняются в порядке, в котором они указаны
  на странице.</span><br>
  <strong>Особенности defer:</strong><br>
  <span>• Загрузка происходит параллельно с HTML.</span>
  <span>• Выполнение происходит только после полной загрузки HTML, что позволяет избежать блокировки парсинга страницы.</span>
  <span>• Порядок выполнения гарантирован, что делает defer удобным для скриптов, зависящих от DOM или других скриптов.</span>
  <span>• document.addEventListener("DOMContentLoaded", function() {console.log("DOM полностью загружен и разобран.");</span>`,
  frequency: 4,
  language: "html",
  codeExample: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Async vs Defer Example</title>
</head>
<body>
  <h1>Пример использования async и defer</h1>

  <!-- Сценарий с атрибутом async -->
  <script async src="async-script.js"></script>

  <!-- Сценарий с атрибутом defer -->
  <script defer src="defer-script.js"></script>

  <p>Текст страницы...</p>
</body>
</html>
`
},
{
  number: 16,
  title: `Асинхронность в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <span><b>Асинхронность</b> в JavaScript помогает выполнять задачи, которые могут занять длительное время, не
  блокируя главный поток выполнения программы. JavaScript работает в одном потоке, и поэтому, когда
  выполняется длительная операция (например, загрузка данных с сервера), необходимо использовать
  асинхронные методы, чтобы интерфейс приложения оставался отзывчивым и не зависал. Основные
  механизмы для работы с асинхронностью в JavaScript — это <b>колбэки (callbacks)</b>, <b>промисы (promises)</b> и
  <b>асинхронные функции (async/await)</b>.</span><br>
  <strong>1. Callbacks</strong><span> это функции, которые передаются как аргументы в другую функцию и вызываются после
  завершения этой функции. В старых версиях JavaScript колбэки были основным способом обработки
  асинхронности, но они часто приводили к так называемому “аду колбэков” (callback hell), когда код
  становился трудно читаемым из-за вложенных функций.</span><br>
  <strong>2. Промисы</strong><span> это объекты, представляющие результат асинхронной операции. Они могут находиться в
  одном из трёх состояний:</span><br>
  <span>• <b>pending (ожидание)</b> — операция ещё не завершена.</span><br>
  <span>• <b>fulfilled (выполнено)</b> — операция успешно завершена.</span><br>
  <span>• <b>rejected (отклонено)</b> — операция завершилась с ошибкой.</span><br>
  <strong>3. Async/Await</strong><span> это синтаксический сахар над промисами, позволяющий писать асинхронный код,
  который выглядит как синхронный. Функции, объявленные с async, возвращают промис,
  а ключевое слово await заставляет интерпретатор JavaScript ждать выполнения промиса.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Функция с callback
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: 'John', age: 30 };
    callback(null, data); // Успешный ответ
  }, 1000);
}

// Вызов с callback
fetchData((error, data) => {
  if (error) {
    console.log('Ошибка:', error);
  } else {
    console.log('Данные с использованием Callback:', data);
  }
});




// Функция с Promise
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { name: 'John', age: 30 };
      resolve(data); // Успешный ответ
    }, 1000);
  });
}

// Вызов с Promise
fetchData()
  .then(data => {
    console.log('Данные с использованием Promise:', data);
  })
  .catch(error => {
    console.log('Ошибка:', error);
  });




  // Функция с async/await
async function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { name: 'John', age: 30 };
      resolve(data); // Успешный ответ
    }, 1000);
  });
}

// Вызов с async/await
async function getData() {
  try {
    const data = await fetchData();
    console.log('Данные с использованием async/await:', data);
  } catch (error) {
    console.log('Ошибка:', error);
  }
}

getData();

`
},
{
  number: 17,
  title: `Что такое EventLoop ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Event Loop (событийный цикл)</strong><br>
  <span>это механизм, который позволяет JavaScript выполнять асинхронные операции и управлять многими задачами, не блокируя основной поток выполнения. Понимание событийного цикла имеет ключевое значение для понимания асинхронного программирования в JavaScript, так как это объясняет, как обрабатываются события и выполняются колбэки.</span><br>
  <strong>Основные компоненты Event Loop</strong><br>
  <span><b>1. Call Stack (Стек вызовов):</b> Это структура данных, которая хранит контекст выполнения текущего кода. Когда вызывается функция, она добавляется в стек, и когда функция завершается, она удаляется из стека. Если стек пуст, значит, нет выполняющегося кода.</span><br>
  <span><b>2. Web APIs:</b> Это API, предоставляемые браузером (или средой выполнения, такой как Node.js), которые
  позволяют выполнять асинхронные операции, такие как HTTP-запросы, таймеры и т. д. Эти операции
  выполняются вне стека вызовов.</span><br>
  <span><b>3. Очередь макротасок:</b> куда попадают задачи от web API</span><br>
  <span><b>4. Очередь микротасок:</b> куда попадают задачи от промисов</span><br>
  <strong>Алгоритм работы Event Loop</strong><br>
  <span>1. Выполняются все синхронные задачи. Задачи от WebAPI отдаются на выполнение браузеру</span><br>
  <span>2. Выполняются все задачи из очереди микротасок (пока очередь не опустеет)</span><br>
  <span>3. Выполняется одна задача из очереди макротасок</span><br>
  <span>4. Производится рендеринг</span><br>
  <span>5. Цикл повторяется</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `console.log('1'); // Выводим в консоль "1"

// Таймаут (макротаск)
setTimeout(() => {
  console.log('2'); // Выводим в консоль "2"
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // Выводим в консоль "3"
}).then(() => {
  console.log('4'); // Выводим в консоль "4"
});

console.log('5'); // Выводим в консоль "5"`
},
{
  number: 18,
  title: `Не мутирующие методы массивов ?`,
  shortAnswer: '',
  longAnswer: `
  <span>Метод <b>map</b> создаёт новый массив, заполняя его результатами вызова заданной функции для каждого элемента исходного массива.</span><br>
  <span>Метод <b>filter</b> создаёт новый массив, содержащий все элементы, которые прошли проверку, заданную в функции.</span><br>
  <span>Метод <b>forEach</b> выполняет указанную функцию один раз для каждого элемента массива. Он не возвращает новый массив.</span><br>
  <span>Метод <b>slice</b> создает новый массив, содержащий копию части исходного массива, не изменяя его.</span><br>
  <span>Метод <b>reduce</b> создает новое значение (не массив) на основе всех элементов массива, используя функцию редукции. Однако этот метод не изменяет исходный массив.</span><br>
  <span>Метод <b>every</b> проверяет, удовлетворяют ли все элементы массива условию, заданному в функции, и возвращает true или false.</span><br>
  <span>Метод <b>some</b> проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции,и возвращает true или false.</span><br>
  <strong>Немутирующие методы массивов позволяют работать с данными, создавая новые массивы или значения без изменения исходных массивов. Это важно для обеспечения предсказуемости и упрощения отладки кода, особенно в функциональном программировании.</strong>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Массив строк
  const words = ['apple', 'banana', 'cherry'];

    // Используем map для преобразования строк в верхний регистр
  const upperCaseWords = words.map(word => word.toUpperCase());

  console.log(upperCaseWords); // ['APPLE', 'BANANA', 'CHERRY']
  `
},
{
  number: 19,
  title: `Мутирующие методы массивов ?`,
  shortAnswer: '',
  longAnswer: `
  <span>Метод <b>push()</b> добавляет один или несколько элементов в конец массива и возвращает новую длину
  массива.</span><br>
  <span>Метод <b>pop()</b> удаляет последний элемент массива и возвращает его. Если массив пуст, возвращает
  undefined.</span><br>
  <span>Метод <b>shift()</b> удаляет первый элемент массива и возвращает его. Если массив пуст, возвращает
  undefined.</span><br>
  <span>Метод <b>unshift()</b> добавляет один или несколько элементов в начало массива и возвращает новую длину
  массива.</span><br>
  <span>Метод <b>splice()</b> позволяет добавлять, удалять или заменять элементы в массиве. Этот метод
  универсален, но несколько сложен в использовании.</span><br>
  <span>Метод <b>sort()</b> сортирует элементы массива на месте и возвращает отсортированный массив. По
  умолчанию сортирует строки в лексикографическом порядке. Для чисел или других объектов часто
  требуется передать функцию сравнения.</span><br>
  <span>Метод <b>reverse()</b> переворачивает массив, изменяя порядок элементов на обратный.</span><br>
  <span>Метод <b>fill()</b> заполняет все элементы массива указанным значением с начального индекса до конечного.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `// Исходный массив
let fruits = ['apple', 'banana', 'cherry'];

// Используем push() — добавляем элемент в конец массива
fruits.push('orange');
console.log(fruits); // ['apple', 'banana', 'cherry', 'orange']

// Используем pop() — удаляем последний элемент массива
let lastFruit = fruits.pop();
console.log(fruits); // ['apple', 'banana', 'cherry']
console.log('Удаленный фрукт:', lastFruit); // 'orange'

// Используем shift() — удаляем первый элемент массива
let firstFruit = fruits.shift();
console.log(fruits); // ['banana', 'cherry']
console.log('Удаленный фрукт:', firstFruit); // 'apple'

// Используем unshift() — добавляем элемент в начало массива
fruits.unshift('strawberry');
console.log(fruits); // ['strawberry', 'banana', 'cherry']

// Используем splice() — удаляем или добавляем элементы в произвольном месте массива
fruits.splice(1, 1, 'blueberry', 'mango');
console.log(fruits); // ['strawberry', 'blueberry', 'mango', 'cherry']
  `
},
{
  number: 20,
  title: `Мeтоды event.preventDeafolt(), evenet.stopPropagination()
  для чего нужны ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>event.preventDefault()</strong><br>
  <span>Этот метод предотвращает выполнение стандартного действия, связанного с событием. Например, если вы нажимаете на ссылку (<code>&lt;a&gt;</code>), браузер обычно переходит по указанному URL. Если вы вызовете event. preventDefault() в обработчике события клика по этой ссылке, переход не произойдёт.</span><br>
  <strong>event.stopPropagation()</strong><br>
  <span>Этот метод останавливает всплытие события, предотвращая его дальнейшую передачу вверх по дереву DOM. В JavaScript события могут “всплывать” от целевого элемента к родительским элементам. Если вы хотите, чтобы событие не доходило до родительских элементов, вы можете использовать event.stopPropagation().</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `document.getElementById('myForm').addEventListener('submit', function(event) {
  event.preventDefault(); // Предотвращаем стандартную отправку формы
  alert('Форма не отправлена!');
  });

  document.getElementById('menu').addEventListener('click', function(event) {
  event.stopPropagation(); // Меню не закроется при клике внутри него
});

document.body.addEventListener('click', function() {
  document.getElementById('menu').style.display = 'none';
});
  `
},
{
  number: 21,
  title: `Что такое DOM-дерево ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>DOM-дерево (Document Object Model)</strong>
  <span>это программный интерфейс для HTML и XML документов. Оно представляет документ в виде дерева узлов, где каждый узел является объектом, с которым можно взаимодействовать при помощи JavaScript. DOM предоставляет методы и свойства для динамического изменения структуры, стилей и содержания документа.</span><br>
  <strong>Структура DOM-дерева</strong><br>
  <span>Корневой элемент: Веб-страница начинается с корневого элемента, который обычно является элементом <html> в HTML-документе.</span><br>
  <strong>Узлы:</strong><br>
  <span>Каждый элемент, атрибут, текст или комментарий в документе представляется как узел. Узлы могут быть разных типов:</span><br>
  <span>• Элемент (Element node): Узел, представляющий HTML-тег (например, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>).</span><br>
  <span>• Текст (Text node): Узел, содержащий текст внутри элемента.</span><br>
  <span>• Атрибут (Attribute node): Узел, представляющий атрибут элемента (например, class, id).</span><br>
  <span>• Комментарий (Comment node): Узел, представляющий комментарий в коде.</span><br>
  <strong>Иерархия:</strong><span> узлы в DOM-дереве организованы в иерархическую структуру. Каждый элемент может
  содержать дочерние элементы, что создает древовидную структуру.</span><br>
  <strong>DOM-дерево</strong><span> это важный концепт в веб-разработке, позволяющий динамически изменять веб-страницы. Понимание структуры и работы DOM позволяет разработчикам создавать интерактивные и динамичные веб-приложения.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 22,
  title: `Что такое всплытие события ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Всплытие события (event bubbling)</strong>
  <span>это механизм в JavaScript, который описывает, как события, происходящие на элементе, поднимаются (всплывают) вверх по дереву DOM к родительским элементам.
  Этот процесс происходит в иерархической структуре документа, и он позволяет родительским элементам реагировать на события, происходящие на их дочерних элементах.</span><br>
  <strong>Как это работает</strong><br>
  <span>Когда событие происходит на элементе (например, клик по кнопке), оно сначала обрабатывается этим элементом. Затем событие “всплывает” вверх к родительскому элементу, и если родитель имеет
  обработчик этого события, он также будет выполнен. Этот процесс продолжается до тех пор, пока событие не достигнет корневого элемента документа (обычно это элемент <code>&lt;html&gt;</code>).</span><br>
  <strong>Всплытие события</strong><br>
  <span>это мощный механизм, который позволяет создавать гибкую обработку событий в JavaScript. Он позволяет родительским элементам реагировать на события своих дочерних элементов,
  что упрощает структуру кода и уменьшает количество обработчиков, необходимых для каждого элемента.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 23,
  title: `Что такое функция высшего порядка ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Функция высшего порядка</strong>
  <span>это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как результат. В JavaScript функции высшего порядка широко используются для абстрагирования операций, таких как итерации, фильтрация, создание замыканий и управление асинхронным кодом.</span><br>
  <strong>Примеры функций высшего порядка</strong><br>
  <span>1. Например, метод массива map является функцией высшего порядка, так как он принимает функцию в качестве аргумента для обработки каждого элемента массива.</span><br>
  <span>2. Функция высшего порядка может возвращать другую функцию. Это позволяет создавать замыкания и настраиваемые функции.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 24,
  title: `Что такое чистая функция ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Чистая функция</strong>
  <span>это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов. Чистые функции являются ключевой концепцией
  в функциональном программировании, так как они делают код более предсказуемым и легко тестируемым.</span><br>
  <strong>Свойства чистых функций</strong><br>
  <span><b>1. Детерминированность:</b> Чистая функция всегда возвращает один и тот же результат, если ей переданы одинаковые аргументы. Например, функция, которая только складывает два числа, будет всегда возвращать одно и то же значение для одних и тех же чисел.</span><br>
  <span><b>2. Отсутствие побочных эффектов:</b> Чистая функция не изменяет внешние состояния, такие как глобальные переменные, значения аргументов или состояния объектов. Она работает только с данными, переданными ей, и не влияет на что-либо за её пределами.</span>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function doubleArray(arr) {
  return arr.map(num => num * 2);
}

const numbers = [1, 2, 3];
console.log(doubleArray(numbers)); // [2, 4, 6]
console.log(numbers); // [1, 2, 3] (исходный массив не изменился)
 `
},
{
  number: 25,
  title: `Функция debounce ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Debounce</strong>
  <span>это функция, которая ограничивает частоту вызова другой функции, обеспечивая, что она будет выполнена только после того, как определенный период времени прошел с момента последнего вызова. Это особенно полезно в ситуациях, когда вы хотите предотвратить выполнение функции, которая может вызываться слишком часто, например, при прокрутке страницы, изменении размеров окна или вводе текста в поле.</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `function debounce(func, delay) {
  let timeout;

  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
}

  // Использование: функция, которая вызывается не чаще, чем раз в 500 мс
  function onSearch(query) {
  console.log("Поиск: " + query);
}

const debouncedSearch = debounce(onSearch, 500);

// Имитация ввода текста (каждый ввод сбрасывает таймер)
debouncedSearch("Hello");
debouncedSearch("Hello, Wo");
debouncedSearch("Hello, World"); // Только этот вызов сработает через 500 мс
 `
},
{
  number: 26,
  title: `В чем отличие package.json и package-lock.json ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>package.json и package-lock.json</strong>
  <span>это файлы, используемые в Node.js для управления зависимостями проекта. Хотя они оба связаны с зависимостями, они имеют разные назначения и работают по-разному.</span><br>
  <strong>package.json</strong>
  <span>это основной файл конфигурации проекта, который: Содержит информацию о проекте: его название, версию, авторов и лицензии.Описывает зависимости, которые необходимы для запуска и разработки проекта. Хранит данные о версиях пакетов, которые подходят для проекта, но не фиксирует точные версии. Управляет скриптами, командами, которые могут запускаться через npm или yarn, например, npm start, npm test.</span><br>
  <strong>package-lock.json</strong><br>
  <span>это файл, автоматически создаваемый при установке пакетов с помощью npm или yarn, который:</span><br>
  <span>• Фиксирует точные версии всех установленных пакетов, включая подзависимости (зависимости
  зависимостей).</span><br>
  <span>• Обеспечивает консистенцию и предсказуемость установки пакетов на разных машинах. Это особенно
  полезно в команде, где всем разработчикам и серверам нужна одинаковая версия каждой зависимости.</span><br>
  <span>• Обновляется при установке новых зависимостей, удалении или изменении версии уже установленных пакетов.</span><br>
  <span>• Не должен редактироваться вручную — изменения вносятся через команды npm или yarn.</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 27,
  title: `Оператор Optional chaining - знак вопроса, что это ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Оператор Optional chaining (?.)</strong>
  <span>это удобный способ безопасно обращаться к вложенным свойствам объектов, которые могут быть null или undefined. Он позволяет избежать ошибок, когда вы пытаетесь получить доступ к свойству, которого может не существовать.</span><br>
  <strong>Как работает Optional chaining</strong><br>
  <span>это удобный способ безопасно обращаться к вложенным свойствам Оператор ?. проверяет, существует ли значение слева от него, и если это значение не null и не undefined, то возвращает следующее свойство. Если же значение null или undefined, то возвращает undefined и останавливает дальнейшее выполнение (не выбрасывает ошибку).</span><br>`,
  frequency: 4,
  language: "javascript",
  codeExample: `const user = {
  name: "Александр",
  address: {
    city: "Москва",
  },
};

console.log(user.name); // "Александр"
console.log(user.address.city); // "Москва"
console.log(user.address?.street); // undefined (без ошибки!)`
},
{
  number: 28,
  title: `Утечки памяти в Javascript ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>Утечки памяти в JavaScript</strong>
  <span>возникают, когда динамически выделенная память перестаёт
  использоваться, но не освобождается должным образом, и остаётся «захваченной» в программе, даже
  если она больше не нужна. Это может приводить к замедлению работы приложения и к значительному
  увеличению его объёма в памяти, особенно в долгоживущих приложениях, таких как веб-приложения с
  множеством взаимодействий и обновлений.</span><br>
  <span>Вот несколько ключевых аспектов, которые помогут понять, что вызывает утечки памяти в JavaScript, и
  как их можно предотвратить:</span><br>
  <strong>Как JavaScript управляет памятью</strong>
  <span>JavaScript использует сборщик мусора (garbage collector), который автоматически освобождает память,
  занимаемую переменными, когда они больше не используются. Сборщик мусора работает по принципу
  достижимости объектов, то есть если объект не может быть достигнут (например, у него нет ни одного
  ссылки), то он считается ненужным и может быть удалён из памяти.</span><br>
  <strong>Основные причины утечек памяти в JavaScript</strong><br>
  <strong>1. Замыкания</strong>
  <span>Позволяют функции запоминать своё окружение и доступ к переменным, определённым
  вне её тела. Если замыкание захватывает переменные, которые больше не используются, и эта функция продолжает ссылаться на них, они остаются в памяти. Особенно это может быть проблемой, если замыкание остаётся в памяти из-за ссылок на него, например, в DOM-элементах или таймерах.</span><br>
  <strong>2. Незавершённые таймеры и обработчики событий</strong>
  <span>Если вы используете setInterval или setTimeout, но не отменяете их с помощью clearInterval или
  clearTimeout, функции, к которым они ссылаются, будут продолжать храниться в памяти. Это также
  относится к слушателям событий, которые не удаляются с элементов после их создания.</span><br>
  <strong>3. Кэширование данных</strong>
  <span>Использование больших структур данных, например, массивов или объектов, для кэширования данных
  (например, результаты API-запросов или промежуточные вычисления) может привести к накоплению
  ненужных объектов в памяти, если старые данные не очищаются. Особенно это критично для
  одностраничных приложений, где данные кэшируются на длительное время.</span><br>
  <strong>4. Глобальные переменные и незавершённые ссылки</strong>
  <span>Глобальные переменные остаются в памяти до конца жизни программы, так как сборщик мусора
  не может освободить их. Похожая проблема может возникнуть, если переменные определяются в
  замыкании и остаются доступными для вызова, даже если они больше не нужны.</span><br>
  <strong>Как найти утечки памяти</strong><br>
  <span><b>1. Использование DevTools:</b> Chrome, имеют вкладку Performance и Memory, которые позволяют отслеживать использование памяти.</span><br>
  <span><b>2. Мониторинг количества объектов и DOM-элементов:</b> Если количество объектов или DOM-элементов растёт после выполнения действий (например, после многократного открытия и закрытия модального окна), это может указывать на утечку памяти.</span><br>
  <span><b>3. Снимки кучи (Heap Snapshots):</b> В DevTools можно сделать снимки кучи памяти до и после выполнения некоторых действий и сравнить их, чтобы увидеть, какие объекты остаются в памяти.</span><br>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 29,
  title: `Что происходит в браузере после того как мы вводим url страницы ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>1. Ввод URL и определение протокола</strong>
  <span>Когда мы вводим URL, браузер распознает протокол (например, http://, https://), доменное имя и путь. Это
  помогает браузеру понять, какой метод доступа будет использован для запроса к серверу.(метод GET).</span><br>
  <strong>2. Проверка кеша</strong>
  <span>Браузер сначала проверяет кешированные данные:
  Кеш браузера: может содержать файлы (HTML, CSS, JS), которые были загружены ранее.
  DNS-кеш: содержит информацию о ранее посещенных доменах и их IP-адресах.
  Кеш промежуточных серверов: такие как CDN или прокси-сервера.
  Если браузер находит кешированную копию запрашиваемой страницы, и эта копия является актуальной, он может сразу отобразить страницу, минуя запрос к серверу.</span><br>
  <strong>3. DNS-резолвинг</strong>
  <span>Если в кеше нет данных о домене, начинается процесс резолвинга DNS. Сначала браузер обращается
  к DNS-серверу, чтобы преобразовать доменное имя (например, example.com) в IP-адрес, связанный с сервером, который обслуживает данный домен. DNS-запрос проходит через несколько уровней:
  Локальный DNS-кеш: хранит записи DNS, если они использовались недавно. DNS-сервер провайдера: сервер интернет-провайдера может хранить кешированные DNS-записи. Корневые DNS-серверы: если IP не найден локально, запрос переходит к серверам, которые управляют доменами верхнего уровня (.com, .ru и т.д.).</span><br>
  <strong>4. Установление соединения</strong>
  <span>После получения IP-адреса браузер начинает устанавливать соединение с сервером. TCP-соединение: браузер и сервер выполняют трехэтапное рукопожатие (3-way handshake), чтобы установить соединение и обеспечить надежность передачи данных. TLS/SSL (если используется HTTPS): браузер и сервер начинают процесс шифрования с помощью TLS/SSL. Они обмениваются ключами, проверяют сертификаты безопасности, чтобы шифровать и защищать передаваемые данные.</span><br>
  <strong>5. Отправка HTTP-запроса</strong>
  <span>После установления соединения браузер отправляет HTTP-запрос на сервер.
  Запрос включает:
  • Метод HTTP (например, GET, POST).
  • Заголовки: информация о браузере, сессии, cookies и т.д.
  • Тело запроса (для POST, PUT запросов).</span><br>
  <strong>6. Обработка запроса на сервере</strong>
  <span>Сервер получает запрос, выполняет необходимые действия (например, запускает программу на сервере для генерации динамического контента или ищет нужный файл) и формирует HTTP-ответ.
  • Статус-код (например, 200 OK, 404 Not Found).
  • Заголовки: тип содержимого, размер, кеширование, cookies и т.д.
  • Тело ответа: HTML-код страницы, данные JSON и т.д.</span><br>
  <strong>7. Получение и обработка HTTP-ответа</strong>
  <span>Браузер получает ответ и проверяет статус-код. Если всё в порядке (например, 200 OK), он начинает разбирать контент страницы, определяя тип содержимого (обычно это HTML).</span><br>
  <strong>8. Парсинг HTML и построение DOM-дерева</strong>
  <span>Браузер начинает парсинг HTML и создает DOM-дерево. DOM (Document Object Model) представляет
  структуру HTML-документа в виде дерева узлов, где каждый узел — это HTML-элемент или текстовый
  узел.</span><br>
  <strong>9. Загрузка и выполнение CSS и JavaScript</strong>
  <span>В процессе построения DOM браузер находит внешние ресурсы, такие как CSS, JavaScript и изображения, и загружает их. <b>CSS:</b> создается CSSOM (CSS Object Model), который вместе с DOM формирует Render Tree, где указаны стили для каждого элемента.
  <b>JavaScript:</b> JS-файлы загружаются и выполняются. Если JavaScript изменяет DOM, браузер обновляет
  дерево DOM. Некоторые скрипты могут блокировать отображение страницы до их выполнения.</span><br>
  <strong>10. Построение и рендеринг Render Tree</strong>
  <span>Браузер объединяет DOM и CSSOM в Render Tree, которое включает только видимые элементы. Это дерево нужно для рендеринга элементов на экране.</span><br>
  <strong>11. Расчёт расположения элементов (Layout)</strong>
  <span>На основе Render Tree браузер рассчитывает точное расположение каждого элемента на странице — этот процесс называется Layout.</span><br>
  <strong>12. Отображение на экране (Painting)</strong>
  <span>Наконец, браузер выполняет отрисовку (Painting), когда каждый элемент получает свои стили и позиции на экране. Графический процессор (GPU) может использоваться для обработки сложных элементов и анимаций.</span><br>
  <strong>Дополнительные процессы</strong>
  <span>Асинхронная загрузка ресурсов: такие ресурсы, как изображения, видео, и асинхронные скрипты загружаются и выполняются параллельно. Оптимизация: браузер может выполнять оптимизации для ускорения загрузки и рендеринга страниц (например, lazy loading, кэширование, оптимизация отрисовки).</span>`,
  frequency: 4,
  language: "javascript",
},
{
  number: 30,
  title: `Разница между HTTP/1.1, HTTP/2, и HTTP/3 ?`,
  shortAnswer: '',
  longAnswer: `
  <strong>HTTP/1.1 (1997)</strong><br>
  <strong>Основные особенности:</strong>
  <span>Последовательные запросы — каждое соединение обслуживает только один запрос за раз.
  <b>Keep-Alive</b> — позволяет использовать одно соединение для нескольких запросов.
  <b>Pipelining (не прижился)</b> — возможность отправлять несколько запросов без ожидания ответов, но сервера редко поддерживали его из-за сложностей.
  <b>Текстовый формат</b> — заголовки отправляются в текстовом виде, что занимает много места.</span><br>
  <strong>HTTP/2 (2015)</strong><br>
  <strong>Что улучшилось:</strong>
  <span><b>Мультиплексирование</b> — несколько запросов выполняются одновременно в одном TCP-соединении.
  <b>Бинарный формат</b> — данные передаются в компактном виде, что снижает объем передаваемых заголовков.
  <b>Сжатие заголовков (HPACK)</b> — уменьшает размер передаваемых данных.
  <b>Server Push</b> —  сервер может отправлять ресурсы клиенту заранее (например, CSS и JS).</span><br>
  <strong>HTTP/3 (2022)</strong><br>
  <strong>Что улучшилось:</strong>
  <span><b>QUIC</b> вместо <b>TCP</b> — каждый запрос обрабатывается независимо, нет общей блокировки.
  <b>Шифрование по умолчанию</b> (TLS 1.3) — защищает передаваемые данные.
  <b>Меньшие задержки</b> (low latency) — быстрее устанавливается соединение.
  <b>Работает лучше при потере пакетов</b> — повторная передача касается только потерянных данных, а не всего потока.</span>
  `,
  frequency: 4,
  language: "javascript",
},
]
